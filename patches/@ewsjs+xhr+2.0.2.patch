diff --git a/node_modules/@ewsjs/xhr/README.md b/node_modules/@ewsjs/xhr/README.md
index 1bdb589..7207e37 100644
--- a/node_modules/@ewsjs/xhr/README.md
+++ b/node_modules/@ewsjs/xhr/README.md
@@ -5,6 +5,10 @@ other related libs will also move to @ewsjs scope/org
 
 > 1.3.0 brings several changes, new api and proxy support. this is also re-written using popular `request` package
 
+## 2.0.0
+* Removed deprecated xhr apis (`cookieAuthXhrApi`, `ntlmAuthXhrApi`, `proxySupportedXhrApi`).
+* removed dependency on `request`, `bluebird` and `fetch`.
+
 ## 1.5.0 
 #15 use pre-call options in stream
 
@@ -93,68 +97,7 @@ let xhr = new XhrApi(true)
 ```
 
 ## Info: No Proxy support with Ntlm (yet!)    
-There are issues whcih needs to be sorted out before Ntlm can be used with proxy, this situation is rarly needed in corporate environment anyways.   
-    
-     
-      
-
-----------------------------
-----------------------------
-# archived 
-## ~~ews-javascript-api-auth~~
-
-A helper library to support NTLM and Cookies authentication with [ews-javascript-api](https://github.com/gautamsi/ews-javascript-api)
-
-## Install
-
-`npm install ews-javascript-api-auth --save`
-
-> 1.2.0 adds support for NTLMv2 (awaiting pull request merge in node-ntlm-client repo, using git install from gihub repo). 1.2.0 removes `httpntlm` package and usage `ntlm-client` due to lack of NTLMv2 support in `httpntlm`
-
-# How to
-## NTLM Authentication or Windows Integrated Authentication with Exchange Web Service
-
-Typescript code:
-```ts
-import { ConfigurationApi } from "ews-javascript-api"; // add other imported objects based on your need
-import { ntlmAuthXhrApi } from "ews-javascript-api-auth"
-ConfigurationApi.ConfigureXHR(new ntlmAuthXhrApi(credentials.userName, credentials.password));
-// ----------other code------------
-```
-
-JavaScript code:
-```js
-var ews = require("ews-javascript-api");
-var ewsAuth = require("ews-javascript-api-auth");
-ews.ConfigurationApi.ConfigureXHR(new ewsAuth.ntlmAuthXhrApi(credentials.userName, credentials.password));
-// ------------rest of code----------------
-```
->  as of version 1.1.0 you can pass `true` as third parameter to the constructer to bypass certificate errors, Note: To be used only for testing and debugging, not suitable for production environment.  
->
->  This should only be needed for ntlm authentication, other scenarios should be fine with use of `process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";` in the calling library. 
-
-
-## Cookies Auth using TMG/ISA
-
-Typescript code:
-```ts
-import { ConfigurationApi } from "ews-javascript-api"; // add other imported objects based on your need
-import { cookieAuthXhrApi } from "ews-javascript-api-auth"
-ConfigurationApi.ConfigureXHR(new cookieAuthXhrApi(credentials.userName, credentials.password));
-// ----------other code------------
-```
-
-JavaScript code:
-```js
-var ews = require("ews-javascript-api");
-var ewsAuth = require("ews-javascript-api-auth");
-ews.ConfigurationApi.ConfigureXHR(new ewsAuth.cookieAuthXhrApi(credentials.userName, credentials.password));
-// ------------rest of code----------------
-```
-
-### requirememnts
-require `ews-javascript-api` version `0.9`
-
+There are issues which needs to be sorted out before Ntlm can be used with proxy, this situation is rarly needed in corporate environment anyways.   
 
 ## License
 MIT
diff --git a/node_modules/@ewsjs/xhr/dist/IProvider.d.ts b/node_modules/@ewsjs/xhr/dist/IProvider.d.ts
index 7b58e46..09f32cf 100644
--- a/node_modules/@ewsjs/xhr/dist/IProvider.d.ts
+++ b/node_modules/@ewsjs/xhr/dist/IProvider.d.ts
@@ -1,6 +1,9 @@
-import { IXHROptions } from "./ews.partial";
-import * as Promise from "bluebird";
+import { AxiosRequestConfig, AxiosInstance } from "axios";
 export interface IProvider {
-    preCall(options: IXHROptions): Promise<IXHROptions>;
+    preCall(options: PreCallConfig): Promise<AxiosRequestConfig>;
     providerName: string;
+    client: AxiosInstance;
 }
+export type PreCallConfig = AxiosRequestConfig & {
+    rejectUnauthorized?: boolean;
+};
diff --git a/node_modules/@ewsjs/xhr/dist/cookieAuthXhrApi.d.ts b/node_modules/@ewsjs/xhr/dist/cookieAuthXhrApi.d.ts
deleted file mode 100644
index e544d46..0000000
--- a/node_modules/@ewsjs/xhr/dist/cookieAuthXhrApi.d.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-import * as Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
-export declare class cookieAuthXhrApi implements IXHRApi {
-    private allowUntrustedCertificate;
-    private stream;
-    private username;
-    private password;
-    private cookies;
-    get apiName(): string;
-    constructor(username: string, password: string, allowUntrustedCertificate?: boolean);
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    disconnect(): void;
-    private cookiesPreCall;
-    private static parseString;
-}
diff --git a/node_modules/@ewsjs/xhr/dist/cookieAuthXhrApi.js b/node_modules/@ewsjs/xhr/dist/cookieAuthXhrApi.js
deleted file mode 100644
index e4fad25..0000000
--- a/node_modules/@ewsjs/xhr/dist/cookieAuthXhrApi.js
+++ /dev/null
@@ -1,187 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.cookieAuthXhrApi = void 0;
-var fetch_1 = require("fetch");
-var Promise = require("bluebird");
-var utils_1 = require("./utils");
-var cookieAuthXhrApi = /** @class */ (function () {
-    function cookieAuthXhrApi(username, password, allowUntrustedCertificate) {
-        if (allowUntrustedCertificate === void 0) { allowUntrustedCertificate = false; }
-        this.allowUntrustedCertificate = allowUntrustedCertificate;
-        this.stream = null;
-        this.username = null;
-        this.password = null;
-        this.cookies = [];
-        this.username = username;
-        this.password = password;
-    }
-    Object.defineProperty(cookieAuthXhrApi.prototype, "apiName", {
-        get: function () {
-            return "cookie";
-        },
-        enumerable: false,
-        configurable: true
-    });
-    cookieAuthXhrApi.prototype.xhr = function (xhroptions, progressDelegate) {
-        var _this = this;
-        if (xhroptions.headers["Authorization"]) {
-            delete xhroptions.headers["Authorization"];
-        }
-        //setup xhr for github.com/andris9/fetch options
-        var options = {
-            url: xhroptions.url,
-            payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: xhroptions.type,
-            cookies: this.cookies
-        };
-        if (this.allowUntrustedCertificate) {
-            options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        }
-        return new Promise(function (resolve, reject) {
-            _this.cookiesPreCall(options).then(function () {
-                options.cookies = _this.cookies;
-                (0, fetch_1.fetchUrl)(options.url, options, function (error, meta, body) {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        // storing more cookies for next request
-                        var cookies = meta.cookieJar.getCookies();
-                        if (!Array.isArray(cookies)) {
-                            cookies = [cookies];
-                        }
-                        _this.cookies = cookies;
-                        // cookies.forEach((cookie) => { // TODO: fix multiple x-backendcookies if needed
-                        //     if (cookie.indexOf('X-BackEndCookie') < 0) { //Exchange 2013 returns different X-BackEndCookie each time
-                        //         if (this.cookies.indexOf(cookie) < 0) {
-                        //             this.cookies.push(cookie);
-                        //         }
-                        //     }
-                        // });
-                        var xhrResponse = {
-                            response: body.toString(),
-                            status: meta.status,
-                            redirectCount: meta.redirectCount,
-                            headers: meta.responseHeaders,
-                            finalUrl: meta.finalUrl,
-                            responseType: '',
-                            statusText: undefined,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                        else {
-                            reject((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                    }
-                });
-            });
-        });
-    };
-    cookieAuthXhrApi.prototype.xhrStream = function (xhroptions, progressDelegate) {
-        var _this = this;
-        //setup xhr for github.com/andris9/fetch options
-        var options = {
-            url: xhroptions.url,
-            payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: xhroptions.type,
-            cookies: this.cookies
-        };
-        return new Promise(function (resolve, reject) {
-            _this.cookiesPreCall(options).then(function () {
-                options.cookies = _this.cookies;
-                _this.stream = new fetch_1.FetchStream(xhroptions.url, options);
-                _this.stream.on("data", function (chunk) {
-                    //console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-                _this.stream.on("meta", function (meta) {
-                    progressDelegate({ type: "header", headers: meta["responseHeaders"] });
-                    // storing more cookies for next request
-                    var cookies = meta['cookieJar'].getCookies();
-                    if (!Array.isArray(cookies)) {
-                        cookies = [cookies];
-                    }
-                    _this.cookies = cookies;
-                    // cookies.forEach((cookie) => { // TODO: fix multiple x-backendcookies if needed
-                    //     if (cookie.indexOf('X-BackEndCookie') < 0) { //Exchange 2013 returns different X-BackEndCookie each time
-                    //         if (this.cookies.indexOf(cookie) < 0) {
-                    //             this.cookies.push(cookie);
-                    //         }
-                    //     }
-                    // });
-                });
-                _this.stream.on("end", function () {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-                _this.stream.on('error', function (error) {
-                    progressDelegate({ type: "error", error: error });
-                    _this.disconnect();
-                    reject(error);
-                });
-            });
-        });
-    };
-    cookieAuthXhrApi.prototype.disconnect = function () {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
-    };
-    cookieAuthXhrApi.prototype.cookiesPreCall = function (options) {
-        var _this = this;
-        return new Promise(function (resolve, reject) {
-            if (!_this.cookies || _this.cookies.length < 1) {
-                var parser = cookieAuthXhrApi.parseString(options.url);
-                var baseUrl = parser.scheme + "://" + parser.authority + "/CookieAuth.dll?Logon";
-                var preauthOptions = {
-                    method: "POST",
-                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
-                    //set body, in fetch it is payload
-                    payload: 'curl=Z2F&flags=0&forcedownlevel=0&formdir=1&trusted=0&username=' + _this.username + '&password=' + _this.password,
-                    url: baseUrl,
-                    disableRedirects: true
-                };
-                if (_this.allowUntrustedCertificate) {
-                    preauthOptions["rejectUnauthorized"] = !_this.allowUntrustedCertificate;
-                }
-                //obtaining cookies
-                (0, fetch_1.fetchUrl)(baseUrl, preauthOptions, function (error, meta, body) {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        //set cookies
-                        var cookies = meta.cookieJar.getCookies();
-                        if (!Array.isArray(cookies)) {
-                            cookies = [cookies];
-                        }
-                        _this.cookies = cookies;
-                        resolve();
-                    }
-                });
-            }
-            else {
-                resolve();
-            }
-        });
-    };
-    cookieAuthXhrApi.parseString = function (url) {
-        var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
-        var parts = url.match(regex);
-        return {
-            scheme: parts[2],
-            authority: parts[4],
-            path: parts[5],
-            query: parts[7],
-            fragment: parts[9]
-        };
-    };
-    return cookieAuthXhrApi;
-}());
-exports.cookieAuthXhrApi = cookieAuthXhrApi;
diff --git a/node_modules/@ewsjs/xhr/dist/cookieProvider.d.ts b/node_modules/@ewsjs/xhr/dist/cookieProvider.d.ts
index 561e000..0f97cb2 100644
--- a/node_modules/@ewsjs/xhr/dist/cookieProvider.d.ts
+++ b/node_modules/@ewsjs/xhr/dist/cookieProvider.d.ts
@@ -1,8 +1,9 @@
-import * as Promise from "bluebird";
-import { IXHROptions } from "./ews.partial";
-import { IProvider } from "./IProvider";
+import { AxiosInstance } from "axios";
+import { IProvider, PreCallConfig } from "./IProvider";
 export declare class CookieProvider implements IProvider {
+    private _client;
     get providerName(): string;
     constructor(username: string, password: string);
-    preCall(options: IXHROptions): Promise<IXHROptions>;
+    get client(): AxiosInstance;
+    preCall(options: PreCallConfig): Promise<PreCallConfig>;
 }
diff --git a/node_modules/@ewsjs/xhr/dist/cookieProvider.js b/node_modules/@ewsjs/xhr/dist/cookieProvider.js
index 3cbabff..dd6bea0 100644
--- a/node_modules/@ewsjs/xhr/dist/cookieProvider.js
+++ b/node_modules/@ewsjs/xhr/dist/cookieProvider.js
@@ -1,12 +1,18 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.CookieProvider = void 0;
-var request = require("request");
-var Promise = require("bluebird");
-var CookieProvider = /** @class */ (function () {
-    function CookieProvider(username, password) {
+const axios_1 = require("axios");
+const http_1 = require("http-cookie-agent/http");
+const tough_cookie_1 = require("tough-cookie");
+class CookieProvider {
+    // private cookies: string[] = [];
+    get providerName() {
+        return "cookie";
+    }
+    constructor(username, password) {
+        this._client = null;
         /**@internal */
-        this.j = null;
+        this.jar = null;
         /**@internal */
         this.username = null;
         /**@internal */
@@ -14,52 +20,47 @@ var CookieProvider = /** @class */ (function () {
         this.username = username || '';
         this.password = password || '';
     }
-    Object.defineProperty(CookieProvider.prototype, "providerName", {
-        // private cookies: string[] = [];
-        get: function () {
-            return "cookie";
-        },
-        enumerable: false,
-        configurable: true
-    });
-    CookieProvider.prototype.preCall = function (options) {
-        var _this = this;
-        return new Promise(function (resolve, reject) {
-            if (options.headers["Authorization"]) {
-                delete options.headers["Authorization"];
-            }
-            // if (!this.cookies || this.cookies.length < 1) {
-            if (!_this.j) {
-                if (!_this.j)
-                    _this.j = request.jar();
-                options.jar = _this.j;
-                var parser = CookieProvider.parseString(options.url);
-                var baseUrl = parser.scheme + "://" + parser.authority + "/CookieAuth.dll?Logon";
-                var preauthOptions = Object.assign({}, options, {
-                    method: "POST",
-                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
-                    body: 'curl=Z2F&flags=0&forcedownlevel=0&formdir=1&trusted=0&username=' + _this.username + '&password=' + _this.password,
-                    url: baseUrl,
-                    disableRedirects: true,
-                });
-                //obtaining cookies
-                request(preauthOptions, function (error, response, body) {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        resolve(options);
-                    }
-                });
+    get client() {
+        return this._client;
+    }
+    async preCall(options) {
+        if (options.headers["Authorization"]) {
+            delete options.headers["Authorization"];
+        }
+        if (!this.jar) {
+            this.jar = new tough_cookie_1.CookieJar();
+            this._client = axios_1.default.create({
+                httpAgent: new http_1.HttpCookieAgent({ cookies: { jar: this.jar } }),
+                httpsAgent: new http_1.HttpsCookieAgent({ cookies: { jar: this.jar }, rejectUnauthorized: options.rejectUnauthorized }),
+            });
+            var parser = CookieProvider.parseString(options.url);
+            var baseUrl = parser.scheme + "://" + parser.authority + "/CookieAuth.dll?Logon";
+            var preauthOptions = Object.assign({}, options, {
+                method: "POST",
+                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
+                data: 'curl=Z2F&flags=0&forcedownlevel=0&formdir=1&trusted=0&username=' + this.username + '&password=' + this.password,
+                url: baseUrl,
+                maxRedirects: 0,
+            });
+            try {
+                await this.client(preauthOptions);
+                return options;
             }
-            else {
-                options.jar = _this.j;
-                resolve(options);
+            catch (error) {
+                throw error;
             }
-        });
-    };
+        }
+        else {
+            if (!this._client)
+                this._client = axios_1.default.create({
+                    httpAgent: new http_1.HttpCookieAgent({ cookies: { jar: this.jar } }),
+                    httpsAgent: new http_1.HttpsCookieAgent({ cookies: { jar: this.jar }, rejectUnauthorized: options.rejectUnauthorized }),
+                });
+            return options;
+        }
+    }
     /**@internal */
-    CookieProvider.parseString = function (url) {
+    static parseString(url) {
         var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
         var parts = url.match(regex);
         return {
@@ -69,7 +70,6 @@ var CookieProvider = /** @class */ (function () {
             query: parts[7],
             fragment: parts[9]
         };
-    };
-    return CookieProvider;
-}());
+    }
+}
 exports.CookieProvider = CookieProvider;
diff --git a/node_modules/@ewsjs/xhr/dist/fetch.d.ts b/node_modules/@ewsjs/xhr/dist/fetch.d.ts
deleted file mode 100644
index ff095d2..0000000
--- a/node_modules/@ewsjs/xhr/dist/fetch.d.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-declare module 'fetch' {
-    export interface Meta {
-        status: number;
-        responseHeaders: any
-        finalUrl: URL;
-        redirectCount: number;
-        cookieJar: any
-    }
-
-    export interface fetchOptions {
-        maxRedirects?: number;
-        disableRedirects?: boolean;
-        headers?: any;
-        maxResponseLength?: number | "infinity";
-        method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'OPTIONS';
-        payload?: string;
-        disableGzip?: boolean;
-        cookies?: any;
-        cookieJar?: any;
-        outputEncoding?: any;
-        disableDecoding?: any;
-        overrideCharset?: any;
-        asyncDnsLoookup?: any;
-        timeout?: number;
-        agentHttps?: any;
-        agentHttp?: any;
-        agent?: any;
-        rejectUnauthorized?: boolean;
-    }
-
-    export class FetchStream {
-        constructor(url: string, options: fetchOptions);
-        destroy(): void;
-        on: (event: 'data' | 'meta' | 'end' | 'error', callback?: (data?: string | Meta) => void) => void;
-    }
-
-    export function fetchUrl(url: string, callback: (error: Error, meta: Meta, body: string) => void): void;
-    export function fetchUrl(url: string, options: fetchOptions, callback: (error: Error, meta: Meta, body: string) => void): void;
-}
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/dist/index.d.ts b/node_modules/@ewsjs/xhr/dist/index.d.ts
index 99e29f8..beefdce 100644
--- a/node_modules/@ewsjs/xhr/dist/index.d.ts
+++ b/node_modules/@ewsjs/xhr/dist/index.d.ts
@@ -1,5 +1,3 @@
-export { ntlmAuthXhrApi } from "./ntlmAuthXhrApi";
-export { cookieAuthXhrApi } from "./cookieAuthXhrApi";
 export { NtlmProvider } from "./ntlmProvider";
 export { CookieProvider } from "./cookieProvider";
 export { XhrApi } from "./xhrApi";
diff --git a/node_modules/@ewsjs/xhr/dist/index.js b/node_modules/@ewsjs/xhr/dist/index.js
index 9d060f6..83c0cd3 100644
--- a/node_modules/@ewsjs/xhr/dist/index.js
+++ b/node_modules/@ewsjs/xhr/dist/index.js
@@ -1,11 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.XhrApi = exports.CookieProvider = exports.NtlmProvider = exports.cookieAuthXhrApi = exports.ntlmAuthXhrApi = void 0;
-var ntlmAuthXhrApi_1 = require("./ntlmAuthXhrApi");
-Object.defineProperty(exports, "ntlmAuthXhrApi", { enumerable: true, get: function () { return ntlmAuthXhrApi_1.ntlmAuthXhrApi; } });
-var cookieAuthXhrApi_1 = require("./cookieAuthXhrApi");
-Object.defineProperty(exports, "cookieAuthXhrApi", { enumerable: true, get: function () { return cookieAuthXhrApi_1.cookieAuthXhrApi; } });
-// export { proxySupportedXhrApi } from "./proxySupportedXhrApi";
+exports.XhrApi = exports.CookieProvider = exports.NtlmProvider = void 0;
 var ntlmProvider_1 = require("./ntlmProvider");
 Object.defineProperty(exports, "NtlmProvider", { enumerable: true, get: function () { return ntlmProvider_1.NtlmProvider; } });
 var cookieProvider_1 = require("./cookieProvider");
diff --git a/node_modules/@ewsjs/xhr/dist/ntlmAuthXhrApi.d.ts b/node_modules/@ewsjs/xhr/dist/ntlmAuthXhrApi.d.ts
deleted file mode 100644
index 9532e7d..0000000
--- a/node_modules/@ewsjs/xhr/dist/ntlmAuthXhrApi.d.ts
+++ /dev/null
@@ -1,15 +0,0 @@
-import * as Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
-export declare class ntlmAuthXhrApi implements IXHRApi {
-    private stream;
-    private username;
-    private password;
-    private domain;
-    private allowUntrustedCertificate;
-    get apiName(): string;
-    constructor(username: string, password: string, allowUntrustedCertificate?: boolean);
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    disconnect(): void;
-    private ntlmPreCall;
-}
diff --git a/node_modules/@ewsjs/xhr/dist/ntlmAuthXhrApi.js b/node_modules/@ewsjs/xhr/dist/ntlmAuthXhrApi.js
deleted file mode 100644
index c8efda9..0000000
--- a/node_modules/@ewsjs/xhr/dist/ntlmAuthXhrApi.js
+++ /dev/null
@@ -1,158 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.ntlmAuthXhrApi = void 0;
-var fetch_1 = require("fetch");
-var Promise = require("bluebird");
-var ntlm_client_1 = require("@ewsjs/ntlm-client");
-var https_1 = require("https");
-var http_1 = require("http");
-var utils_1 = require("./utils");
-var ntlmAuthXhrApi = /** @class */ (function () {
-    function ntlmAuthXhrApi(username, password, allowUntrustedCertificate) {
-        if (allowUntrustedCertificate === void 0) { allowUntrustedCertificate = false; }
-        this.stream = null;
-        this.username = null;
-        this.password = null;
-        this.domain = '';
-        this.username = username || '';
-        this.password = password || '';
-        this.allowUntrustedCertificate = allowUntrustedCertificate;
-        if (username.indexOf("\\") > 0) {
-            this.username = username.split("\\")[1];
-            this.domain = username.split("\\")[0].toUpperCase();
-        }
-    }
-    Object.defineProperty(ntlmAuthXhrApi.prototype, "apiName", {
-        get: function () {
-            return "ntlm";
-        },
-        enumerable: false,
-        configurable: true
-    });
-    ntlmAuthXhrApi.prototype.xhr = function (xhroptions, progressDelegate) {
-        var _this = this;
-        //setup xhr for github.com/andris9/fetch options
-        var options = {
-            url: xhroptions.url,
-            //payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: 'GET',
-            agentHttps: new https_1.Agent({ keepAlive: true, rejectUnauthorized: !this.allowUntrustedCertificate }),
-            agentHttp: new http_1.Agent({ keepAlive: true }) //keepaliveAgent
-        };
-        return new Promise(function (resolve, reject) {
-            _this.ntlmPreCall(options).then(function (optionsWithNtlmHeader) {
-                optionsWithNtlmHeader['payload'] = xhroptions.data;
-                optionsWithNtlmHeader['method'] = xhroptions.type;
-                (0, fetch_1.fetchUrl)(xhroptions.url, optionsWithNtlmHeader, function (error, meta, body) {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        var xhrResponse = {
-                            response: body.toString(),
-                            status: meta.status,
-                            redirectCount: meta.redirectCount,
-                            headers: meta.responseHeaders,
-                            finalUrl: meta.finalUrl,
-                            responseType: '',
-                            statusText: undefined,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                        else {
-                            reject((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                    }
-                });
-            }, reject);
-        });
-    };
-    ntlmAuthXhrApi.prototype.xhrStream = function (xhroptions, progressDelegate) {
-        var _this = this;
-        //setup xhr for github.com/andris9/fetch options
-        var options = {
-            url: xhroptions.url,
-            //payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: 'GET',
-            agentHttps: new https_1.Agent({ keepAlive: true, rejectUnauthorized: !this.allowUntrustedCertificate }),
-            agentHttp: new http_1.Agent({ keepAlive: true }) //keepaliveAgent
-        };
-        return new Promise(function (resolve, reject) {
-            _this.ntlmPreCall(options).then(function (optionsWithNtlmHeader) {
-                optionsWithNtlmHeader['payload'] = xhroptions.data;
-                optionsWithNtlmHeader['method'] = xhroptions.type;
-                _this.stream = new fetch_1.FetchStream(xhroptions.url, optionsWithNtlmHeader);
-                _this.stream.on("data", function (chunk) {
-                    //console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-                _this.stream.on("meta", function (meta) {
-                    progressDelegate({ type: "header", headers: meta["responseHeaders"] });
-                });
-                _this.stream.on("end", function () {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-                _this.stream.on('error', function (error) {
-                    progressDelegate({ type: "error", error: error });
-                    _this.disconnect();
-                    reject(error);
-                });
-            }, reject);
-        });
-    };
-    ntlmAuthXhrApi.prototype.disconnect = function () {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
-    };
-    ntlmAuthXhrApi.prototype.ntlmPreCall = function (options) {
-        var ntlmOptions = {
-            url: options.url,
-            username: this.username,
-            password: this.password,
-            workstation: options['workstation'] || '',
-            domain: this.domain
-        };
-        return new Promise(function (resolve, reject) {
-            var type1msg = (0, ntlm_client_1.createType1Message)(ntlmOptions.workstation, ntlmOptions.domain);
-            options.headers['Authorization'] = type1msg;
-            options.headers['Connection'] = 'keep-alive';
-            (0, fetch_1.fetchUrl)(options.url, options, function (error, meta, body) {
-                if (error) {
-                    reject(error);
-                }
-                else {
-                    var xhrResponse = {
-                        response: body,
-                        status: meta.status,
-                        redirectCount: meta.redirectCount,
-                        headers: meta.responseHeaders,
-                        finalUrl: meta.finalUrl,
-                        responseType: '',
-                        statusText: undefined,
-                    };
-                    resolve(xhrResponse);
-                }
-            });
-        }).then(function (res) {
-            if (!res.headers['www-authenticate'])
-                throw new Error('www-authenticate not found on response of second request');
-            var type2msg = (0, ntlm_client_1.decodeType2Message)(res.headers['www-authenticate']);
-            var type3msg = (0, ntlm_client_1.createType3Message)(type2msg, ntlmOptions.username, ntlmOptions.password, ntlmOptions.workstation, ntlmOptions.domain); //with ntlm-client
-            delete options.headers['authorization']; // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-            delete options.headers['connection']; // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-            options.headers['Authorization'] = type3msg;
-            options.headers['Connection'] = 'Close';
-            return options;
-        });
-    };
-    return ntlmAuthXhrApi;
-}());
-exports.ntlmAuthXhrApi = ntlmAuthXhrApi;
diff --git a/node_modules/@ewsjs/xhr/dist/ntlmProvider.d.ts b/node_modules/@ewsjs/xhr/dist/ntlmProvider.d.ts
index 52f2e85..4bc15e0 100644
--- a/node_modules/@ewsjs/xhr/dist/ntlmProvider.d.ts
+++ b/node_modules/@ewsjs/xhr/dist/ntlmProvider.d.ts
@@ -1,11 +1,12 @@
-import * as Promise from "bluebird";
-import { IXHROptions } from "./ews.partial";
-import { IProvider } from "./IProvider";
+import { AxiosInstance } from "axios";
+import { IProvider, PreCallConfig } from "./IProvider";
 export declare class NtlmProvider implements IProvider {
+    private _client;
     private username;
     private password;
     private domain;
     get providerName(): string;
     constructor(username: string, password: string);
-    preCall(options: IXHROptions): Promise<IXHROptions>;
+    get client(): AxiosInstance;
+    preCall(options: PreCallConfig): Promise<PreCallConfig>;
 }
diff --git a/node_modules/@ewsjs/xhr/dist/ntlmProvider.js b/node_modules/@ewsjs/xhr/dist/ntlmProvider.js
index b91622a..df9a914 100644
--- a/node_modules/@ewsjs/xhr/dist/ntlmProvider.js
+++ b/node_modules/@ewsjs/xhr/dist/ntlmProvider.js
@@ -1,12 +1,15 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.NtlmProvider = void 0;
-var request = require("request");
-var Promise = require("bluebird");
-var ntlm_client_1 = require("@ewsjs/ntlm-client");
-var https_1 = require("https");
-var NtlmProvider = /** @class */ (function () {
-    function NtlmProvider(username, password) {
+const axios_1 = require("axios");
+const ntlm_client_1 = require("@ewsjs/ntlm-client");
+const https_1 = require("https");
+class NtlmProvider {
+    get providerName() {
+        return "ntlm";
+    }
+    constructor(username, password) {
+        this._client = null;
         this.username = null;
         this.password = null;
         this.domain = '';
@@ -17,53 +20,40 @@ var NtlmProvider = /** @class */ (function () {
             this.domain = username.split("\\")[0].toUpperCase();
         }
     }
-    Object.defineProperty(NtlmProvider.prototype, "providerName", {
-        get: function () {
-            return "ntlm";
-        },
-        enumerable: false,
-        configurable: true
-    });
-    NtlmProvider.prototype.preCall = function (options) {
-        var ntlmOptions = {
+    get client() {
+        return this._client;
+    }
+    async preCall(options) {
+        let ntlmOptions = {
             url: options.url,
             username: this.username,
             password: this.password,
             workstation: options['workstation'] || '.',
             domain: this.domain,
         };
-        return new Promise(function (resolve, reject) {
-            options.headers['Connection'] = 'keep-alive';
-            options["jar"] = true;
-            options["agent"] = new https_1.Agent({ keepAlive: true, rejectUnauthorized: options.rejectUnauthorized });
-            var type1msg = (0, ntlm_client_1.createType1Message)(ntlmOptions.workstation, ntlmOptions.domain); // alternate client - ntlm-client
-            var opt = Object.assign({}, options);
-            opt['method'] = "GET";
-            opt.headers['Authorization'] = type1msg;
-            delete opt['body'];
-            request(opt, function (error, response, body) {
-                try {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        if (!response.headers['www-authenticate'])
-                            throw new Error('www-authenticate not found on response of second request');
-                        var type2msg = (0, ntlm_client_1.decodeType2Message)(response.headers['www-authenticate']);
-                        var type3msg = (0, ntlm_client_1.createType3Message)(type2msg, ntlmOptions.username, ntlmOptions.password, ntlmOptions.workstation, ntlmOptions.domain);
-                        delete options.headers['authorization']; // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-                        delete options.headers['connection']; // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-                        options.headers['Authorization'] = type3msg;
-                        options.headers['Connection'] = 'Close';
-                        resolve(options);
-                    }
-                }
-                catch (err) {
-                    reject(err);
-                }
-            });
-        });
-    };
-    return NtlmProvider;
-}());
+        options.headers['Connection'] = 'keep-alive';
+        options.httpsAgent = new https_1.Agent({ keepAlive: true, rejectUnauthorized: options.rejectUnauthorized });
+        let type1msg = (0, ntlm_client_1.createType1Message)(ntlmOptions.workstation, ntlmOptions.domain); // alternate client - ntlm-client
+        let opt = Object.assign({}, options);
+        opt['method'] = "GET";
+        opt.headers['Authorization'] = type1msg;
+        delete opt['data'];
+        delete opt['responseType'];
+        try {
+            const response = await (0, axios_1.default)(opt).catch(err => err.response);
+            if (!response.headers['www-authenticate'])
+                throw new Error('www-authenticate not found on response of second request');
+            let type2msg = (0, ntlm_client_1.decodeType2Message)(response.headers['www-authenticate']);
+            let type3msg = (0, ntlm_client_1.createType3Message)(type2msg, ntlmOptions.username, ntlmOptions.password, ntlmOptions.workstation, ntlmOptions.domain);
+            delete options.headers['authorization']; // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
+            delete options.headers['connection']; // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
+            options.headers['Authorization'] = type3msg;
+            options.headers['Connection'] = 'Close';
+            return options;
+        }
+        catch (err) {
+            throw err;
+        }
+    }
+}
 exports.NtlmProvider = NtlmProvider;
diff --git a/node_modules/@ewsjs/xhr/dist/proxySupportedXhrApi.d.ts b/node_modules/@ewsjs/xhr/dist/proxySupportedXhrApi.d.ts
deleted file mode 100644
index eadce7a..0000000
--- a/node_modules/@ewsjs/xhr/dist/proxySupportedXhrApi.d.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import * as Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
-import { IProvider } from "./IProvider";
-export declare class proxySupportedXhrApi implements IXHRApi {
-    proxyUrl: string;
-    proxyUser: string;
-    proxyPassword: string;
-    allowUntrustedCertificate: boolean;
-    private stream;
-    get apiName(): string;
-    constructor(proxyUrl: string);
-    constructor(proxyUrl: string, allowUntrustedCertificate: boolean);
-    constructor(proxyUrl: string, proxyUserName: string, proxyPassword: string);
-    constructor(proxyUrl: string, proxyUserName: string, proxyPassword: string, allowUntrustedCertificate: boolean);
-    SetProvider(provider: IProvider): void;
-    private provider;
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    disconnect(): void;
-    getProxyString(): string;
-}
diff --git a/node_modules/@ewsjs/xhr/dist/proxySupportedXhrApi.js b/node_modules/@ewsjs/xhr/dist/proxySupportedXhrApi.js
deleted file mode 100644
index c58d2e1..0000000
--- a/node_modules/@ewsjs/xhr/dist/proxySupportedXhrApi.js
+++ /dev/null
@@ -1,178 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.proxySupportedXhrApi = void 0;
-var request = require("request");
-var Promise = require("bluebird");
-var utils_1 = require("./utils");
-var proxySupportedXhrApi = /** @class */ (function () {
-    function proxySupportedXhrApi(proxyUrl, proxyUserNameOrallowUntrustedCertificate, proxyPassword, allowUntrustedCertificate) {
-        if (proxyUserNameOrallowUntrustedCertificate === void 0) { proxyUserNameOrallowUntrustedCertificate = false; }
-        if (proxyPassword === void 0) { proxyPassword = null; }
-        if (allowUntrustedCertificate === void 0) { allowUntrustedCertificate = false; }
-        this.proxyUrl = null;
-        this.proxyUser = null;
-        this.proxyPassword = null;
-        this.provider = null;
-        this.proxyUrl = proxyUrl;
-        if (typeof proxyUserNameOrallowUntrustedCertificate === 'string') {
-            this.proxyUser = proxyUserNameOrallowUntrustedCertificate;
-            this.proxyPassword = proxyPassword;
-            this.allowUntrustedCertificate = allowUntrustedCertificate;
-        }
-        else {
-            this.allowUntrustedCertificate = proxyUserNameOrallowUntrustedCertificate;
-        }
-    }
-    Object.defineProperty(proxySupportedXhrApi.prototype, "apiName", {
-        get: function () {
-            return "proxy";
-        },
-        enumerable: false,
-        configurable: true
-    });
-    proxySupportedXhrApi.prototype.SetProvider = function (provider) {
-        this.provider = provider;
-    };
-    proxySupportedXhrApi.prototype.xhr = function (xhroptions, progressDelegate) {
-        var _this = this;
-        //setup xhr for github.com/andris9/fetch options
-        var options = {
-            url: xhroptions.url,
-            body: xhroptions.data,
-            headers: xhroptions.headers,
-            method: xhroptions.type,
-            followRedirect: false,
-            //resolveWithFullResponse: true
-        };
-        var proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
-        }
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        return new Promise(function (resolve, reject) {
-            var _promise = Promise.resolve(options);
-            if (_this.provider) {
-                _promise = _this.provider.preCall(options);
-            }
-            _promise.then(function (opt) {
-                console.log("in proxy");
-                console.log(opt);
-                request(opt || options, function (error, response, body) {
-                    if (error) {
-                        rejectWithError(reject, error);
-                    }
-                    else {
-                        var xhrResponse = {
-                            response: body ? body.toString() : '',
-                            status: response.statusCode,
-                            //redirectCount: meta.redirectCount,
-                            headers: response.headers,
-                            finalUrl: response.url,
-                            responseType: '',
-                            statusText: response.statusMessage,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                        else {
-                            reject((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                    }
-                });
-            }, function (reason) {
-                reject((0, utils_1.setupXhrResponse)(reason));
-            });
-        });
-    };
-    proxySupportedXhrApi.prototype.xhrStream = function (xhroptions, progressDelegate) {
-        var _this = this;
-        //setup xhr for github.com/andris9/fetch options
-        var options = {
-            url: xhroptions.url,
-            body: xhroptions.data,
-            headers: xhroptions.headers,
-            method: xhroptions.type,
-            followRedirect: false,
-        };
-        var proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
-        }
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        return new Promise(function (resolve, reject) {
-            var _promise = Promise.resolve(options);
-            if (_this.provider) {
-                _promise = _this.provider.preCall(options);
-            }
-            _promise.then(function (opt) {
-                _this.stream = request(options);
-                _this.stream.on('response', function (response) {
-                    // unmodified http.IncomingMessage object
-                    progressDelegate({ type: "header", headers: response["headers"] });
-                });
-                _this.stream.on("data", function (chunk) {
-                    // decompressed data as it is received
-                    // console.log('decoded chunk: ' + chunk)
-                    // console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-                _this.stream.on("end", function () {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-                _this.stream.on('error', function (error) {
-                    progressDelegate({ type: "error", error: error });
-                    _this.disconnect();
-                    rejectWithError(reject, error);
-                });
-            }, function (reason) {
-                reject((0, utils_1.setupXhrResponse)(reason));
-            });
-        });
-    };
-    proxySupportedXhrApi.prototype.disconnect = function () {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
-    };
-    proxySupportedXhrApi.prototype.getProxyString = function () {
-        if (this.proxyUrl) {
-            var str = this.proxyUrl;
-            if (this.proxyUser && this.proxyPassword) {
-                var proxyParts = this.proxyUrl.split("://");
-                return (proxyParts[0] + "://" + this.proxyUser + ":" + this.proxyPassword + "@" + proxyParts[1]);
-            }
-            else {
-                return this.proxyUrl;
-            }
-        }
-        return null;
-    };
-    return proxySupportedXhrApi;
-}());
-exports.proxySupportedXhrApi = proxySupportedXhrApi;
-function rejectWithError(reject, reason) {
-    var xhrResponse = {
-        response: reason.response && reason.response.body ? reason.response.body.toString() : '',
-        status: reason.statusCode,
-        //redirectCount: meta.redirectCount,
-        headers: reason.response ? reason.response.headers : {},
-        finalUrl: reason.url,
-        responseType: '',
-        statusText: reason.message,
-        message: reason.message
-    };
-    if (typeof xhrResponse.status === 'undefined' && reason.message) {
-        try {
-            var parse = reason.message.match(/statusCode=(\d*?)$/);
-            if (parse && parse.length > 1) {
-                xhrResponse["status"] = Number(parse[1]);
-            }
-        }
-        catch (e) { }
-    }
-    reject((0, utils_1.setupXhrResponse)(xhrResponse));
-}
diff --git a/node_modules/@ewsjs/xhr/dist/utils.js b/node_modules/@ewsjs/xhr/dist/utils.js
index d14af74..d2d2e4a 100644
--- a/node_modules/@ewsjs/xhr/dist/utils.js
+++ b/node_modules/@ewsjs/xhr/dist/utils.js
@@ -14,7 +14,7 @@ function setupXhrResponse(xhrResponse) {
         }
         return header;
     };
-    xhrResponse.getResponseHeader = function (header) {
+    xhrResponse.getResponseHeader = (header) => {
         if (header) {
             if (xhrResponse.headers) {
                 if (xhrResponse.headers[header]) {
diff --git a/node_modules/@ewsjs/xhr/dist/xhrApi.d.ts b/node_modules/@ewsjs/xhr/dist/xhrApi.d.ts
index 281e5ac..38afcd1 100644
--- a/node_modules/@ewsjs/xhr/dist/xhrApi.d.ts
+++ b/node_modules/@ewsjs/xhr/dist/xhrApi.d.ts
@@ -1,6 +1,5 @@
-import { CoreOptions } from "request";
-import * as Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
+import { AxiosRequestConfig } from 'axios';
+import { IXHROptions, IXHRApi, IXHRProgress } from "../types/ews.partial";
 import { IProvider } from "./IProvider";
 /**
  * this is alternate XHR Api for ews-javascript-api/ewsjs
@@ -10,8 +9,8 @@ import { IProvider } from "./IProvider";
  * @implements {IXHRApi}
  */
 export declare class XhrApi implements IXHRApi {
-    static defaultOptions: CoreOptions;
-    requestOptions: CoreOptions;
+    static defaultOptions: AxiosRequestConfig;
+    requestOptions: AxiosRequestConfig;
     private allowUntrustedCertificate;
     private proxyConfig;
     get apiName(): string;
@@ -25,7 +24,9 @@ export declare class XhrApi implements IXHRApi {
      * @param {CoreOptions} requestOptions Options for request
      * @memberof XhrApi
      */
-    constructor(requestOptions: CoreOptions);
+    constructor(requestOptions: AxiosRequestConfig & {
+        rejectUnauthorized?: boolean;
+    });
     /**
      * Creates an instance of XhrApi. optionally pass true to bypass remote ssl/tls certificate check
      * @param {boolean} allowUntrustedCertificate whether to allow non trusted certificate or not
@@ -71,5 +72,6 @@ export declare class XhrApi implements IXHRApi {
     xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
     disconnect(): void;
     private getProxyString;
+    private getProxyOption;
     private getOptions;
 }
diff --git a/node_modules/@ewsjs/xhr/dist/xhrApi.js b/node_modules/@ewsjs/xhr/dist/xhrApi.js
index 2f81a85..1295cb5 100644
--- a/node_modules/@ewsjs/xhr/dist/xhrApi.js
+++ b/node_modules/@ewsjs/xhr/dist/xhrApi.js
@@ -1,11 +1,11 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.XhrApi = void 0;
-var request = require("request");
-var Promise = require("bluebird");
-var utils_1 = require("./utils");
-var ntlmProvider_1 = require("./ntlmProvider");
-var cookieProvider_1 = require("./cookieProvider");
+const https = require("https");
+const axios_1 = require("axios");
+const utils_1 = require("./utils");
+const ntlmProvider_1 = require("./ntlmProvider");
+const cookieProvider_1 = require("./cookieProvider");
 /**
  * this is alternate XHR Api for ews-javascript-api/ewsjs
  *
@@ -13,9 +13,18 @@ var cookieProvider_1 = require("./cookieProvider");
  * @class XhrApi
  * @implements {IXHRApi}
  */
-var XhrApi = /** @class */ (function () {
-    function XhrApi(aucoro) {
-        if (aucoro === void 0) { aucoro = false; }
+class XhrApi {
+    get apiName() {
+        let n = "request";
+        if (this.proxyConfig.enabled = true) {
+            n += ";proxy:yes";
+        }
+        if (this.authProvider) {
+            n += ";auth:" + this.authProvider.providerName;
+        }
+        return "request";
+    }
+    constructor(aucoro = false) {
         this.requestOptions = {};
         this.proxyConfig = {
             enabled: false,
@@ -33,20 +42,6 @@ var XhrApi = /** @class */ (function () {
             this.allowUntrustedCertificate = !!aucoro;
         }
     }
-    Object.defineProperty(XhrApi.prototype, "apiName", {
-        get: function () {
-            var n = "request";
-            if (this.proxyConfig.enabled = true) {
-                n += ";proxy:yes";
-            }
-            if (this.authProvider) {
-                n += ";auth:" + this.authProvider.providerName;
-            }
-            return "request";
-        },
-        enumerable: false,
-        configurable: true
-    });
     /**
      * Enable use of Proxy server when using this XHR Api
      *
@@ -56,15 +51,13 @@ var XhrApi = /** @class */ (function () {
      * @returns {XhrApi} returns instance for chaining
      * @memberof XhrApi
      */
-    XhrApi.prototype.useProxy = function (url, proxyUserName, proxyPassword) {
-        if (proxyUserName === void 0) { proxyUserName = null; }
-        if (proxyPassword === void 0) { proxyPassword = null; }
+    useProxy(url, proxyUserName = null, proxyPassword = null) {
         if (this.authProvider instanceof ntlmProvider_1.NtlmProvider) {
             throw new Error("NtlmProvider does not work with proxy (yet!)");
         }
         this.proxyConfig = { enabled: url !== null, url: url, userName: proxyUserName, password: proxyPassword };
         return this;
-    };
+    }
     /**
      * use NTLM authentication method, supports Ntlm v2
      *
@@ -73,13 +66,13 @@ var XhrApi = /** @class */ (function () {
      * @returns {XhrApi} returns instance for chaining
      * @memberof XhrApi
      */
-    XhrApi.prototype.useNtlmAuthentication = function (username, password) {
+    useNtlmAuthentication(username, password) {
         if (this.proxyConfig.enabled === true) {
             throw new Error("NtlmProvider does not work with proxy (yet!)");
         }
         this.authProvider = new ntlmProvider_1.NtlmProvider(username, password);
         return this;
-    };
+    }
     /**
      * use cookies authentication method, usually required when hosted behind ISA/TMG
      *
@@ -88,137 +81,135 @@ var XhrApi = /** @class */ (function () {
      * @returns {XhrApi} returns instance for chaining
      * @memberof XhrApi
      */
-    XhrApi.prototype.useCookieAuthentication = function (username, password) {
+    useCookieAuthentication(username, password) {
         this.authProvider = new cookieProvider_1.CookieProvider(username, password);
         return this;
-    };
+    }
     /**
      * set custom IProvider interface, needed for custom IProvider implementing custom precall method
      *
      * @param {IProvider} authProvider auth provider implementing IProvider interface
      * @memberof XhrApi
      */
-    XhrApi.prototype.setAuthProvider = function (authProvider) {
+    setAuthProvider(authProvider) {
         this.authProvider = authProvider;
-    };
-    XhrApi.prototype.xhr = function (xhroptions, progressDelegate) {
-        var _this = this;
+    }
+    async xhr(xhroptions, progressDelegate) {
+        let client = axios_1.default.create();
         //setup xhr for github.com/andris9/fetch options
-        var options = {
+        let options = {
             url: xhroptions.url,
-            body: xhroptions.data,
+            data: xhroptions.data,
             headers: xhroptions.headers,
             method: xhroptions.type,
-            followRedirect: !!xhroptions.allowRedirect,
+            maxRedirects: !xhroptions.allowRedirect ? 0 : 5,
             //resolveWithFullResponse: true
         };
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        // if (this.allowUntrustedCertificate) {
-        //     options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        // }
-        var proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
+        if (this.allowUntrustedCertificate) {
+            options.httpsAgent = new https.Agent({ rejectUnauthorized: false });
+        }
+        let proxyConfig = this.getProxyOption();
+        if (proxyConfig) {
+            options["proxy"] = proxyConfig;
         }
         options = this.getOptions(options);
-        return new Promise(function (resolve, reject) {
-            var _promise = Promise.resolve(options);
-            if (_this.authProvider) {
-                _promise = _this.authProvider.preCall(options);
+        let _promise = Promise.resolve(options);
+        try {
+            if (this.authProvider) {
+                _promise = this.authProvider.preCall({ ...options, rejectUnauthorized: !this.allowUntrustedCertificate });
+                client = this.authProvider.client || client;
             }
-            _promise.then(function (opt) {
-                // console.log("in proxy");
-                // console.log(opt);
-                request(opt || options, function (error, response, body) {
-                    if (error) {
-                        rejectWithError(reject, error);
-                    }
-                    else {
-                        var xhrResponse = {
-                            response: body ? body.toString() : '',
-                            status: response.statusCode,
-                            //redirectCount: meta.redirectCount,
-                            headers: response.headers,
-                            finalUrl: response.url,
-                            responseType: '',
-                            statusText: response.statusMessage,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                        else {
-                            reject((0, utils_1.setupXhrResponse)(xhrResponse));
-                        }
-                    }
-                });
-            }, function (reason) {
-                reject((0, utils_1.setupXhrResponse)(reason));
-            });
-        });
-    };
-    XhrApi.prototype.xhrStream = function (xhroptions, progressDelegate) {
-        var _this = this;
+            const opt = await _promise;
+            // console.log({ opt });
+            const response = await client(opt || options);
+            // if (error) {
+            //   rejectWithError(reject, error);
+            // }
+            let xhrResponse = {
+                response: response.data ? response.data.toString() : '',
+                status: response.status,
+                //redirectCount: meta.redirectCount,
+                headers: response.headers,
+                finalUrl: response.headers.location || response.request.res.responseUrl,
+                responseType: '',
+                statusText: response.statusText,
+            };
+            if (xhrResponse.status === 200) {
+                return (0, utils_1.setupXhrResponse)(xhrResponse);
+            }
+            else {
+                throw (0, utils_1.setupXhrResponse)(xhrResponse);
+            }
+        }
+        catch (error) {
+            throw (0, utils_1.setupXhrResponse)(error);
+        }
+    }
+    xhrStream(xhroptions, progressDelegate) {
+        let client = axios_1.default.create();
         //setup xhr for github.com/andris9/fetch options
-        var options = {
+        let options = {
             url: xhroptions.url,
-            body: xhroptions.data,
+            data: xhroptions.data,
             headers: xhroptions.headers,
             method: xhroptions.type,
-            followRedirect: false,
+            maxRedirects: !xhroptions.allowRedirect ? 0 : 5,
+            responseType: 'stream',
         };
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        // if (this.allowUntrustedCertificate) {
-        //     options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        // }
-        var proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
+        if (this.allowUntrustedCertificate) {
+            options.httpsAgent = new https.Agent({ rejectUnauthorized: false });
+        }
+        let proxyConfig = this.getProxyOption();
+        if (proxyConfig) {
+            options["proxy"] = proxyConfig;
         }
         options = this.getOptions(options);
-        return new Promise(function (resolve, reject) {
-            var _promise = Promise.resolve(options);
-            if (_this.authProvider) {
-                _promise = _this.authProvider.preCall(options);
+        return new Promise((resolve, reject) => {
+            let _promise = Promise.resolve(options);
+            if (this.authProvider) {
+                _promise = this.authProvider.preCall({ ...options, rejectUnauthorized: !this.allowUntrustedCertificate });
+                client = this.authProvider.client || client;
             }
-            _promise.then(function (opt) {
-                _this.stream = request(opt || options);
-                _this.stream.on('response', function (response) {
+            _promise.then(async (opt) => {
+                const response = await client(opt || options);
+                this.stream = response.data;
+                this.stream.on('response', function (response) {
                     // unmodified http.IncomingMessage object
                     progressDelegate({ type: "header", headers: response["headers"] });
                 });
-                _this.stream.on("data", function (chunk) {
+                this.stream.on("data", (chunk) => {
                     // decompressed data as it is received
                     // console.log('decoded chunk: ' + chunk)
                     // console.log(chunk.toString());
                     progressDelegate({ type: "data", data: chunk.toString() });
                 });
-                _this.stream.on("end", function () {
+                this.stream.on("end", () => {
                     progressDelegate({ type: "end" });
-                    resolve();
+                    resolve(null);
                 });
-                _this.stream.on('error', function (error) {
+                this.stream.on('error', (error) => {
                     progressDelegate({ type: "error", error: error });
-                    _this.disconnect();
+                    this.disconnect();
                     rejectWithError(reject, error);
                 });
-            }, function (reason) {
+            }, reason => {
                 reject((0, utils_1.setupXhrResponse)(reason));
             });
         });
-    };
-    XhrApi.prototype.disconnect = function () {
+    }
+    disconnect() {
         if (this.stream) {
             try {
                 this.stream.destroy();
             }
             catch (e) { }
         }
-    };
-    XhrApi.prototype.getProxyString = function () {
+    }
+    getProxyString() {
         if (this.proxyConfig.enabled) {
-            var url = this.proxyConfig.url;
+            let url = this.proxyConfig.url;
             if (this.proxyConfig.userName && this.proxyConfig.password) {
-                var proxyParts = url.split("://");
+                let proxyParts = url.split("://");
                 return (proxyParts[0] + "://" + encodeURIComponent(this.proxyConfig.userName) + ":" + encodeURIComponent(this.proxyConfig.password) + "@" + proxyParts[1]);
             }
             else {
@@ -226,17 +217,41 @@ var XhrApi = /** @class */ (function () {
             }
         }
         return null;
-    };
-    XhrApi.prototype.getOptions = function (opts) {
-        var headers = Object.assign({}, (XhrApi.defaultOptions || {}).headers, (this.requestOptions || {}).headers, (opts || {}).headers);
-        return Object.assign({}, XhrApi.defaultOptions, this.requestOptions, opts, { headers: headers });
-    };
-    XhrApi.defaultOptions = {};
-    return XhrApi;
-}());
+    }
+    getProxyOption() {
+        if (this.proxyConfig.enabled) {
+            let url = this.proxyConfig.url;
+            let proxyParts = new URL(url);
+            if (this.proxyConfig.userName && this.proxyConfig.password) {
+                return {
+                    protocol: proxyParts.protocol,
+                    host: proxyParts.host,
+                    port: proxyParts.port ? Number(proxyParts.port) : 80,
+                    auth: {
+                        username: this.proxyConfig.userName,
+                        password: this.proxyConfig.password
+                    }
+                };
+            }
+            else {
+                return {
+                    protocol: proxyParts.protocol,
+                    host: proxyParts.host,
+                    port: proxyParts.port ? Number(proxyParts.port) : 80,
+                };
+            }
+        }
+        return null;
+    }
+    getOptions(opts) {
+        let headers = Object.assign({}, (XhrApi.defaultOptions || {}).headers, (this.requestOptions || {}).headers, (opts || {}).headers);
+        return Object.assign({}, XhrApi.defaultOptions, this.requestOptions, opts, { headers });
+    }
+}
 exports.XhrApi = XhrApi;
+XhrApi.defaultOptions = {};
 function rejectWithError(reject, reason) {
-    var xhrResponse = {
+    let xhrResponse = {
         response: reason.response && reason.response.body ? reason.response.body.toString() : '',
         status: reason.statusCode,
         //redirectCount: meta.redirectCount,
@@ -248,7 +263,7 @@ function rejectWithError(reject, reason) {
     };
     if (typeof xhrResponse.status === 'undefined' && reason.message) {
         try {
-            var parse = reason.message.match(/statusCode=(\d*?)$/);
+            let parse = reason.message.match(/statusCode=(\d*?)$/);
             if (parse && parse.length > 1) {
                 xhrResponse["status"] = Number(parse[1]);
             }
diff --git a/node_modules/@ewsjs/xhr/src/IProvider.ts b/node_modules/@ewsjs/xhr/src/IProvider.ts
index ac43dfb..08ba43f 100644
--- a/node_modules/@ewsjs/xhr/src/IProvider.ts
+++ b/node_modules/@ewsjs/xhr/src/IProvider.ts
@@ -1,8 +1,9 @@
-import { IXHROptions } from "./ews.partial";
-import * as  Promise from "bluebird";
+import { AxiosRequestConfig, AxiosInstance } from "axios";
 
 export interface IProvider {
-    preCall(options: IXHROptions): Promise<IXHROptions>;
-    providerName: string;
-
+  preCall(options: PreCallConfig): Promise<AxiosRequestConfig>;
+  providerName: string;
+  client: AxiosInstance;
 }
+
+export type PreCallConfig = AxiosRequestConfig & { rejectUnauthorized?: boolean };
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/src/cookieAuthXhrApi.ts b/node_modules/@ewsjs/xhr/src/cookieAuthXhrApi.ts
deleted file mode 100644
index d8793b4..0000000
--- a/node_modules/@ewsjs/xhr/src/cookieAuthXhrApi.ts
+++ /dev/null
@@ -1,197 +0,0 @@
-import { FetchStream, fetchUrl, Meta } from 'fetch';
-import * as request from 'request';
-import * as  Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
-import { setupXhrResponse } from "./utils";
-
-export class cookieAuthXhrApi implements IXHRApi {
-
-    private stream: FetchStream = null;
-    private username: string = null
-    private password: string = null
-    private cookies: string[] = [];
-
-    get apiName(): string {
-        return "cookie";
-    }
-
-    constructor(username: string, password: string, private allowUntrustedCertificate: boolean = false) {
-        this.username = username;
-        this.password = password;
-    }
-
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        if (xhroptions.headers["Authorization"]) {
-            delete xhroptions.headers["Authorization"];
-        }
-
-        //setup xhr for github.com/andris9/fetch options
-        let options = {
-            url: xhroptions.url,
-            payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: <any>xhroptions.type,
-            cookies: this.cookies
-        }
-
-        if (this.allowUntrustedCertificate) {
-            options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        }
-
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-            this.cookiesPreCall(options).then(() => {
-                options.cookies = this.cookies;
-                fetchUrl(options.url, options, (error, meta, body) => {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        // storing more cookies for next request
-                        let cookies: string[] = meta.cookieJar.getCookies();
-                        if (!Array.isArray(cookies)) {
-                            cookies = [cookies];
-                        }
-                        this.cookies = cookies;
-                        // cookies.forEach((cookie) => { // TODO: fix multiple x-backendcookies if needed
-                        //     if (cookie.indexOf('X-BackEndCookie') < 0) { //Exchange 2013 returns different X-BackEndCookie each time
-                        //         if (this.cookies.indexOf(cookie) < 0) {
-                        //             this.cookies.push(cookie);
-                        //         }
-                        //     }
-                        // });
-                        let xhrResponse: XMLHttpRequest = <any>{
-                            response: body.toString(),
-                            status: meta.status,
-                            redirectCount: meta.redirectCount,
-                            headers: meta.responseHeaders,
-                            finalUrl: meta.finalUrl,
-                            responseType: '',
-                            statusText: undefined,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve(setupXhrResponse(xhrResponse));
-                        }
-                        else {
-                            reject(setupXhrResponse(xhrResponse));
-                        }
-                    }
-                });
-            });
-        })
-    }
-
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        //setup xhr for github.com/andris9/fetch options
-        let options = {
-            url: xhroptions.url,
-            payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: <any>xhroptions.type,
-            cookies: this.cookies
-        }
-
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-            this.cookiesPreCall(options).then(() => {
-                options.cookies = this.cookies;
-                this.stream = new FetchStream(xhroptions.url, options);
-
-                this.stream.on("data", (chunk: string) => {
-                    //console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-
-                this.stream.on("meta", (meta: Meta) => {
-                    progressDelegate({ type: "header", headers: meta["responseHeaders"] });
-                    // storing more cookies for next request
-                    let cookies: string[] = meta['cookieJar'].getCookies();
-                    if (!Array.isArray(cookies)) {
-                        cookies = [cookies];
-                    }
-                    this.cookies = cookies;
-                    // cookies.forEach((cookie) => { // TODO: fix multiple x-backendcookies if needed
-                    //     if (cookie.indexOf('X-BackEndCookie') < 0) { //Exchange 2013 returns different X-BackEndCookie each time
-                    //         if (this.cookies.indexOf(cookie) < 0) {
-                    //             this.cookies.push(cookie);
-                    //         }
-                    //     }
-                    // });
-                });
-
-                this.stream.on("end", () => {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-
-                this.stream.on('error', (error) => {
-                    progressDelegate({ type: "error", error: error });
-                    this.disconnect();
-                    reject(error);
-                });
-            });
-        });
-    }
-
-    disconnect() {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
-    }
-
-    private cookiesPreCall(options: IXHROptions): Promise<void> {
-
-        return new Promise<void>((resolve, reject) => {
-            if (!this.cookies || this.cookies.length < 1) {
-                var parser = cookieAuthXhrApi.parseString(options.url);
-                var baseUrl = parser.scheme + "://" + parser.authority + "/CookieAuth.dll?Logon";
-                var preauthOptions = {
-                    method: <any>"POST",
-                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
-                    //set body, in fetch it is payload
-                    payload: 'curl=Z2F&flags=0&forcedownlevel=0&formdir=1&trusted=0&username=' + this.username + '&password=' + this.password,
-                    url: baseUrl,
-                    disableRedirects: true
-                }
-                if (this.allowUntrustedCertificate) {
-                    preauthOptions["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-                }
-                //obtaining cookies
-                fetchUrl(baseUrl, preauthOptions, (error, meta, body) => {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        //set cookies
-                        let cookies: string[] = meta.cookieJar.getCookies();
-                        if (!Array.isArray(cookies)) {
-                            cookies = [cookies];
-                        }
-                        this.cookies = cookies;
-                        resolve();
-                    }
-                });
-            }
-            else {
-                resolve();
-            }
-        });
-    }
-
-    private static parseString(url: string) {
-        var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
-        var parts = url.match(regex);
-        return {
-            scheme: parts[2],
-            authority: parts[4],
-            path: parts[5],
-            query: parts[7],
-            fragment: parts[9]
-        };
-    }
-
-}
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/src/cookieProvider.ts b/node_modules/@ewsjs/xhr/src/cookieProvider.ts
index 4a7523e..0acb61c 100644
--- a/node_modules/@ewsjs/xhr/src/cookieProvider.ts
+++ b/node_modules/@ewsjs/xhr/src/cookieProvider.ts
@@ -1,75 +1,79 @@
-import * as request from 'request';
-import * as  Promise from "bluebird";
-import { IXHROptions } from "./ews.partial";
+import axios, { AxiosRequestConfig, AxiosInstance } from "axios";
+import { HttpCookieAgent, HttpsCookieAgent, createCookieAgent } from 'http-cookie-agent/http';
+import { CookieJar } from 'tough-cookie';
 
-import { IProvider } from "./IProvider";
+import { IProvider, PreCallConfig } from "./IProvider";
 
-import { Agent as httpsAgent } from "https";
+export class CookieProvider implements IProvider {
+  private _client: AxiosInstance = null;
+  /**@internal */
+  private jar = null;
+  /**@internal */
+  private username: string = null;
+  /**@internal */
+  private password: string = null;
+  // private cookies: string[] = [];
 
+  get providerName(): string {
+    return "cookie";
+  }
 
-export class CookieProvider implements IProvider {
-    /**@internal */
-    private j = null;
-    /**@internal */
-    private username: string = null;
-    /**@internal */
-    private password: string = null;
-    // private cookies: string[] = [];
+  constructor(username: string, password: string) {
+    this.username = username || '';
+    this.password = password || '';
+  }
 
-    get providerName(): string {
-        return "cookie";
-    }
+  get client(): AxiosInstance {
+    return this._client;
+  }
 
-    constructor(username: string, password: string) {
-        this.username = username || '';
-        this.password = password || '';
+  async preCall(options: PreCallConfig) {
+    if (options.headers["Authorization"]) {
+      delete options.headers["Authorization"];
     }
 
-    preCall(options: IXHROptions) {
-        return new Promise<IXHROptions>((resolve, reject) => {
-            if (options.headers["Authorization"]) {
-                delete options.headers["Authorization"];
-            }
-            // if (!this.cookies || this.cookies.length < 1) {
-            if (!this.j) {
-                if (!this.j) this.j = request.jar();
-                options.jar = this.j;
-                var parser = CookieProvider.parseString(options.url);
-                var baseUrl = parser.scheme + "://" + parser.authority + "/CookieAuth.dll?Logon";
-                var preauthOptions = Object.assign({}, options, {
-                    method: <any>"POST",
-                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
-                    body: 'curl=Z2F&flags=0&forcedownlevel=0&formdir=1&trusted=0&username=' + this.username + '&password=' + this.password,
-                    url: baseUrl,
-                    disableRedirects: true,
-                });
-                //obtaining cookies
-                request(preauthOptions, (error, response, body) => {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        resolve(options);
-                    }
-                });
-            }
-            else {
-                options.jar = this.j;
-                resolve(options);
-            }
-        });
-    }
+    if (!this.jar) {
+      this.jar = new CookieJar();
+      this._client = axios.create({
+        httpAgent: new HttpCookieAgent({ cookies: { jar: this.jar } }),
+        httpsAgent: new HttpsCookieAgent({ cookies: { jar: this.jar }, rejectUnauthorized: options.rejectUnauthorized }),
+      });
+
+      var parser = CookieProvider.parseString(options.url);
+      var baseUrl = parser.scheme + "://" + parser.authority + "/CookieAuth.dll?Logon";
+      var preauthOptions = Object.assign({}, options, <AxiosRequestConfig>{
+        method: "POST",
+        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
+        data: 'curl=Z2F&flags=0&forcedownlevel=0&formdir=1&trusted=0&username=' + this.username + '&password=' + this.password,
+        url: baseUrl,
+        maxRedirects: 0,
+      });
 
-    /**@internal */
-    private static parseString(url: string) {
-        var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
-        var parts = url.match(regex);
-        return {
-            scheme: parts[2],
-            authority: parts[4],
-            path: parts[5],
-            query: parts[7],
-            fragment: parts[9]
-        };
+      try {
+        await this.client(preauthOptions);
+        return options;
+      } catch (error) {
+        throw error;
+      }
+    } else {
+      if (!this._client) this._client = axios.create({
+        httpAgent: new HttpCookieAgent({ cookies: { jar: this.jar } }),
+        httpsAgent: new HttpsCookieAgent({ cookies: { jar: this.jar }, rejectUnauthorized: options.rejectUnauthorized }),
+      });
+      return options;
     }
+  }
+
+  /**@internal */
+  private static parseString(url: string) {
+    var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
+    var parts = url.match(regex);
+    return {
+      scheme: parts[2],
+      authority: parts[4],
+      path: parts[5],
+      query: parts[7],
+      fragment: parts[9]
+    };
+  }
 }
diff --git a/node_modules/@ewsjs/xhr/src/ews.partial.d.ts b/node_modules/@ewsjs/xhr/src/ews.partial.d.ts
deleted file mode 100644
index 66c34b5..0000000
--- a/node_modules/@ewsjs/xhr/src/ews.partial.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-import * as Promise from "bluebird";
-export interface IXHROptions {
-    type?: string;
-    url: string;
-    user?: string;
-    password?: string;
-    headers?: any;
-    data?: any;
-    responseType?: string;
-    allowRedirect?: boolean;
-    customRequestInitializer?: (request: XMLHttpRequest) => void;
-    cookies?: any;
-    jar?: any;
-    rejectUnauthorized?: any;
-    proxy?: any;
-}
-export interface IXHRProgress {
-    type: 'data' | 'header' | 'end' | 'error';
-    data?: string;
-    chunk?: string;
-    progress?: number;
-    done?: boolean;
-    headers?: any;
-    originalHeaders?: any;
-    error?: any;
-}
-export interface IXHRApi {
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest>;
-    disconnect(): void;
-    apiName?: string;
-}
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/src/fetch.d.ts b/node_modules/@ewsjs/xhr/src/fetch.d.ts
deleted file mode 100644
index ff095d2..0000000
--- a/node_modules/@ewsjs/xhr/src/fetch.d.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-declare module 'fetch' {
-    export interface Meta {
-        status: number;
-        responseHeaders: any
-        finalUrl: URL;
-        redirectCount: number;
-        cookieJar: any
-    }
-
-    export interface fetchOptions {
-        maxRedirects?: number;
-        disableRedirects?: boolean;
-        headers?: any;
-        maxResponseLength?: number | "infinity";
-        method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'OPTIONS';
-        payload?: string;
-        disableGzip?: boolean;
-        cookies?: any;
-        cookieJar?: any;
-        outputEncoding?: any;
-        disableDecoding?: any;
-        overrideCharset?: any;
-        asyncDnsLoookup?: any;
-        timeout?: number;
-        agentHttps?: any;
-        agentHttp?: any;
-        agent?: any;
-        rejectUnauthorized?: boolean;
-    }
-
-    export class FetchStream {
-        constructor(url: string, options: fetchOptions);
-        destroy(): void;
-        on: (event: 'data' | 'meta' | 'end' | 'error', callback?: (data?: string | Meta) => void) => void;
-    }
-
-    export function fetchUrl(url: string, callback: (error: Error, meta: Meta, body: string) => void): void;
-    export function fetchUrl(url: string, options: fetchOptions, callback: (error: Error, meta: Meta, body: string) => void): void;
-}
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/src/index.ts b/node_modules/@ewsjs/xhr/src/index.ts
index 11cbd4e..dbe93d5 100644
--- a/node_modules/@ewsjs/xhr/src/index.ts
+++ b/node_modules/@ewsjs/xhr/src/index.ts
@@ -1,6 +1,3 @@
-export { ntlmAuthXhrApi } from "./ntlmAuthXhrApi";
-export { cookieAuthXhrApi } from "./cookieAuthXhrApi";
-// export { proxySupportedXhrApi } from "./proxySupportedXhrApi";
 export { NtlmProvider } from "./ntlmProvider";
 export { CookieProvider } from "./cookieProvider";
 export { XhrApi } from "./xhrApi";
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/src/ntlmAuthXhrApi.ts b/node_modules/@ewsjs/xhr/src/ntlmAuthXhrApi.ts
deleted file mode 100644
index 311a28a..0000000
--- a/node_modules/@ewsjs/xhr/src/ntlmAuthXhrApi.ts
+++ /dev/null
@@ -1,179 +0,0 @@
-import { FetchStream, fetchUrl } from 'fetch';
-import * as  Promise from "bluebird";
-import { createType1Message, decodeType2Message, createType3Message } from "@ewsjs/ntlm-client";
-import { Agent as httpsAgent } from "https";
-import { Agent as httpAgent } from "http";
-
-import { setupXhrResponse } from "./utils";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
-
-export class ntlmAuthXhrApi implements IXHRApi {
-
-    private stream: FetchStream = null;
-    private username: string = null;
-    private password: string = null;
-    private domain: string = '';
-    private allowUntrustedCertificate: boolean;
-
-    get apiName(): string {
-        return "ntlm";
-    }
-
-    constructor(username: string, password: string, allowUntrustedCertificate: boolean = false) {
-
-        this.username = username || '';
-        this.password = password || '';
-        this.allowUntrustedCertificate = allowUntrustedCertificate;
-
-        if (username.indexOf("\\") > 0) {
-            this.username = username.split("\\")[1];
-            this.domain = username.split("\\")[0].toUpperCase();
-        }
-    }
-
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        //setup xhr for github.com/andris9/fetch options
-        let options = {
-            url: xhroptions.url,
-            //payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: 'GET',
-            agentHttps: new httpsAgent({ keepAlive: true, rejectUnauthorized: !this.allowUntrustedCertificate }), //keepaliveAgent
-            agentHttp: new httpAgent({ keepAlive: true }) //keepaliveAgent
-        }
-
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-            this.ntlmPreCall(options).then((optionsWithNtlmHeader) => {
-
-                optionsWithNtlmHeader['payload'] = xhroptions.data;
-                optionsWithNtlmHeader['method'] = <any>xhroptions.type
-                fetchUrl(xhroptions.url, optionsWithNtlmHeader, (error, meta, body) => {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        let xhrResponse: XMLHttpRequest = <any>{
-                            response: body.toString(),
-                            status: meta.status,
-                            redirectCount: meta.redirectCount,
-                            headers: meta.responseHeaders,
-                            finalUrl: meta.finalUrl,
-                            responseType: '',
-                            statusText: undefined,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve(setupXhrResponse(xhrResponse));
-                        }
-                        else {
-                            reject(setupXhrResponse(xhrResponse));
-                        }
-                    }
-                });
-            }, reject);
-        })
-    }
-
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        //setup xhr for github.com/andris9/fetch options
-        let options = {
-            url: xhroptions.url,
-            //payload: xhroptions.data,
-            headers: xhroptions.headers,
-            method: 'GET',
-            agentHttps: new httpsAgent({ keepAlive: true, rejectUnauthorized: !this.allowUntrustedCertificate }), //keepaliveAgent
-            agentHttp: new httpAgent({ keepAlive: true }) //keepaliveAgent
-        }
-
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-            this.ntlmPreCall(options).then((optionsWithNtlmHeader) => {
-
-                optionsWithNtlmHeader['payload'] = xhroptions.data;
-                optionsWithNtlmHeader['method'] = <any>xhroptions.type
-
-                this.stream = new FetchStream(xhroptions.url, optionsWithNtlmHeader);
-
-                this.stream.on("data", (chunk) => {
-                    //console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-
-                this.stream.on("meta", (meta) => {
-                    progressDelegate({ type: "header", headers: meta["responseHeaders"] });
-                });
-
-                this.stream.on("end", () => {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-
-                this.stream.on('error', (error) => {
-                    progressDelegate({ type: "error", error: error });
-                    this.disconnect();
-                    reject(error);
-                });
-            }, reject);
-        });
-    }
-
-    disconnect() {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
-    }
-
-    private ntlmPreCall(options: IXHROptions, ) {
-        let ntlmOptions = {
-            url: options.url,
-            username: this.username,
-            password: this.password,
-            workstation: options['workstation'] || '',
-            domain: this.domain
-        };
-
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-            let type1msg = createType1Message(ntlmOptions.workstation, ntlmOptions.domain);
-
-            options.headers['Authorization'] = type1msg;
-            options.headers['Connection'] = 'keep-alive';
-
-            fetchUrl(options.url, options, (error, meta, body) => {
-                if (error) {
-                    reject(error);
-                }
-                else {
-                    let xhrResponse: XMLHttpRequest = <any>{
-                        response: body,
-                        status: meta.status,
-                        redirectCount: meta.redirectCount,
-                        headers: meta.responseHeaders,
-                        finalUrl: meta.finalUrl,
-                        responseType: '',
-                        statusText: undefined,
-                    };
-                    resolve(xhrResponse);
-                }
-            });
-        }).then((res: any) => {
-            if (!res.headers['www-authenticate'])
-                throw new Error('www-authenticate not found on response of second request');
-
-            let type2msg = decodeType2Message(res.headers['www-authenticate']);
-            let type3msg = createType3Message(type2msg, ntlmOptions.username, ntlmOptions.password, ntlmOptions.workstation, ntlmOptions.domain); //with ntlm-client
-
-            delete options.headers['authorization'] // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-            delete options.headers['connection'] // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-
-            options.headers['Authorization'] = type3msg;
-            options.headers['Connection'] = 'Close';
-
-            return options;
-        });
-    }
-}
diff --git a/node_modules/@ewsjs/xhr/src/ntlmProvider.ts b/node_modules/@ewsjs/xhr/src/ntlmProvider.ts
index a06faf0..86361f8 100644
--- a/node_modules/@ewsjs/xhr/src/ntlmProvider.ts
+++ b/node_modules/@ewsjs/xhr/src/ntlmProvider.ts
@@ -1,79 +1,127 @@
-import * as request from 'request';
-import * as  Promise from "bluebird";
+import axios, { AxiosRequestConfig, AxiosInstance } from "axios";
 import { createType1Message, decodeType2Message, createType3Message } from "@ewsjs/ntlm-client";
 import { Agent as httpsAgent } from "https";
 
-import { IXHROptions } from "./ews.partial";
-import { IProvider } from "./IProvider";
-
+import { IProvider, PreCallConfig } from "./IProvider";
 
 export class NtlmProvider implements IProvider {
 
-    private username: string = null;
-    private password: string = null;
-    private domain: string = '';
+  private _client: AxiosInstance = null;
 
-    get providerName(): string {
-        return "ntlm";
-    }
+  private username: string = null;
+  private password: string = null;
+  private domain: string = '';
 
-    constructor(username: string, password: string) {
+  get providerName(): string {
+    return "ntlm";
+  }
 
-        this.username = username || '';
-        this.password = password || '';
+  constructor(username: string, password: string) {
 
-        if (username.indexOf("\\") > 0) {
-            this.username = username.split("\\")[1];
-            this.domain = username.split("\\")[0].toUpperCase();
-        }
-    }
+    this.username = username || '';
+    this.password = password || '';
 
-    preCall(options: IXHROptions) {
-        let ntlmOptions = {
-            url: options.url,
-            username: this.username,
-            password: this.password,
-            workstation: options['workstation'] || '.',
-            domain: this.domain,
-        };
-
-        return new Promise<IXHROptions>((resolve, reject) => {
-
-            options.headers['Connection'] = 'keep-alive';
-
-            options["jar"] = true;
-
-            options["agent"] = new httpsAgent({ keepAlive: true, rejectUnauthorized: options.rejectUnauthorized })
-            let type1msg = createType1Message(ntlmOptions.workstation, ntlmOptions.domain); // alternate client - ntlm-client
-            let opt = (<any>Object).assign({}, options);
-            opt['method'] = "GET";
-            opt.headers['Authorization'] = type1msg;
-            delete opt['body'];
-
-            request(opt, (error, response, body) => {
-                try {
-                    if (error) {
-                        reject(error);
-                    }
-                    else {
-                        
-                        if (!response.headers['www-authenticate'])
-                            throw new Error('www-authenticate not found on response of second request');
-
-                        let type2msg = decodeType2Message(response.headers['www-authenticate']);
-                        let type3msg = createType3Message(type2msg, ntlmOptions.username, ntlmOptions.password, ntlmOptions.workstation, ntlmOptions.domain);
-
-                        delete options.headers['authorization'] // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-                        delete options.headers['connection'] // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
-
-                        options.headers['Authorization'] = type3msg;
-                        options.headers['Connection'] = 'Close';
-                        resolve(options);
-                    }
-                } catch (err) {
-                    reject(err);
-                }
-            });
-        });
+    if (username.indexOf("\\") > 0) {
+      this.username = username.split("\\")[1];
+      this.domain = username.split("\\")[0].toUpperCase();
+    }
+  }
+
+  get client(): AxiosInstance {
+    return this._client;
+  }
+
+  async preCall(options: PreCallConfig) {
+    let ntlmOptions = {
+      url: options.url,
+      username: this.username,
+      password: this.password,
+      workstation: options['workstation'] || '.',
+      domain: this.domain,
+    };
+
+    console.log('[DEBUG] NTLM Provider - Starting NTLM authentication');
+    console.log('[DEBUG] NTLM Provider - Target URL:', options.url);
+    console.log('[DEBUG] NTLM Provider - Domain:', this.domain);
+    console.log('[DEBUG] NTLM Provider - Username:', this.username);
+    console.log('[DEBUG] NTLM Provider - Workstation:', ntlmOptions.workstation);
+    console.log('[DEBUG] NTLM Provider - Reject Unauthorized:', options.rejectUnauthorized);
+
+    options.headers['Connection'] = 'keep-alive';
+
+    options.httpsAgent = new httpsAgent({ keepAlive: true, rejectUnauthorized: options.rejectUnauthorized })
+    let type1msg = createType1Message(ntlmOptions.workstation, ntlmOptions.domain); // alternate client - ntlm-client
+    
+    console.log('[DEBUG] NTLM Provider - Type 1 Message generated:', type1msg);
+    
+    let opt: AxiosRequestConfig = (<any>Object).assign({}, options);
+    opt['method'] = "GET";
+    opt.headers['Authorization'] = type1msg;
+    delete opt['data'];
+    delete opt['responseType'];
+
+    console.log('[DEBUG] NTLM Provider - Sending Type 1 request');
+    console.log('[DEBUG] NTLM Provider - Request headers:', JSON.stringify(opt.headers, null, 2));
+
+    try {
+      const response = await axios(opt).catch(err => {
+        console.log('[DEBUG] NTLM Provider - axios error caught during Type 1 request:', err);
+        console.log('[DEBUG] NTLM Provider - Error code:', err.code);
+        console.log('[DEBUG] NTLM Provider - Error message:', err.message);
+        console.log('[DEBUG] NTLM Provider - Error stack:', err.stack);
+        
+        if (err.response) {
+          console.log('[DEBUG] NTLM Provider - Error response status:', err.response.status);
+          console.log('[DEBUG] NTLM Provider - Error response statusText:', err.response.statusText);
+          console.log('[DEBUG] NTLM Provider - Error response headers:', JSON.stringify(err.response.headers, null, 2));
+          console.log('[DEBUG] NTLM Provider - Error response data:', err.response.data);
+        } else {
+          console.log('[DEBUG] NTLM Provider - No response in error, network or connection issue');
+          console.log('[DEBUG] NTLM Provider - Error config URL:', err.config?.url);
+          console.log('[DEBUG] NTLM Provider - Error config timeout:', err.config?.timeout);
+          throw err;
+        }
+        return err.response;
+      });
+
+      console.log('[DEBUG] NTLM Provider - Type 1 response received');
+      console.log('[DEBUG] NTLM Provider - Response status:', response.status);
+      console.log('[DEBUG] NTLM Provider - Response statusText:', response.statusText);
+      console.log('[DEBUG] NTLM Provider - Response headers:', JSON.stringify(response.headers, null, 2));
+
+      if (!response.headers['www-authenticate']) {
+        console.log('[DEBUG] NTLM Provider - CRITICAL: www-authenticate header missing!');
+        console.log('[DEBUG] NTLM Provider - Available headers:', Object.keys(response.headers));
+        throw new Error('www-authenticate not found on response of second request');
+      }
+
+      console.log('[DEBUG] NTLM Provider - www-authenticate header found:', response.headers['www-authenticate']);
+
+      let type2msg = decodeType2Message(response.headers['www-authenticate']);
+      console.log('[DEBUG] NTLM Provider - Type 2 message decoded successfully');
+      console.log('[DEBUG] NTLM Provider - Type 2 message details:', JSON.stringify(type2msg, null, 2));
+
+      let type3msg = createType3Message(type2msg, ntlmOptions.username, ntlmOptions.password, ntlmOptions.workstation, ntlmOptions.domain);
+      console.log('[DEBUG] NTLM Provider - Type 3 message generated:', type3msg);
+
+      delete options.headers['authorization'] // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
+      delete options.headers['connection'] // 'fetch' has this wired addition with lower case, with lower case ntlm on server side fails
+
+      options.headers['Authorization'] = type3msg;
+      options.headers['Connection'] = 'Close';
+      
+      console.log('[DEBUG] NTLM Provider - Final request headers prepared:', JSON.stringify(options.headers, null, 2));
+      console.log('[DEBUG] NTLM Provider - NTLM authentication setup completed successfully');
+      
+      return options;
+    } catch (err) {
+      console.log('[DEBUG] NTLM Provider - FATAL ERROR in preCall:');
+      console.log('[DEBUG] NTLM Provider - Error type:', typeof err);
+      console.log('[DEBUG] NTLM Provider - Error instanceof Error:', err instanceof Error);
+      console.log('[DEBUG] NTLM Provider - Error message:', err.message);
+      console.log('[DEBUG] NTLM Provider - Error stack:', err.stack);
+      console.log('[DEBUG] NTLM Provider - Error details:', JSON.stringify(err, Object.getOwnPropertyNames(err), 2));
+      throw err;
     }
+  }
 }
diff --git a/node_modules/@ewsjs/xhr/src/proxySupportedXhrApi.ts b/node_modules/@ewsjs/xhr/src/proxySupportedXhrApi.ts
deleted file mode 100644
index 802e99b..0000000
--- a/node_modules/@ewsjs/xhr/src/proxySupportedXhrApi.ts
+++ /dev/null
@@ -1,215 +0,0 @@
-import * as request from 'request';
-import * as  Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
-import { setupXhrResponse } from "./utils";
-
-import { Agent as httpsAgent } from "https";
-import { ClientResponse } from "http"
-import { IProvider } from "./IProvider";
-
-
-
-
-export class proxySupportedXhrApi implements IXHRApi {
-
-    proxyUrl: string = null;
-    proxyUser: string = null;
-    proxyPassword: string = null;
-    allowUntrustedCertificate: boolean;
-
-    private stream: any;
-
-    get apiName(): string {
-        return "proxy";
-    }
-
-    constructor(proxyUrl: string)
-    constructor(proxyUrl: string, allowUntrustedCertificate: boolean)
-    constructor(proxyUrl: string, proxyUserName: string, proxyPassword: string)
-    constructor(proxyUrl: string, proxyUserName: string, proxyPassword: string, allowUntrustedCertificate: boolean)
-    constructor(proxyUrl: string, proxyUserNameOrallowUntrustedCertificate: string | boolean = false, proxyPassword: string = null, allowUntrustedCertificate: boolean = false) {
-        this.proxyUrl = proxyUrl;
-
-        if (typeof proxyUserNameOrallowUntrustedCertificate === 'string') {
-            this.proxyUser = proxyUserNameOrallowUntrustedCertificate;
-            this.proxyPassword = proxyPassword
-            this.allowUntrustedCertificate = allowUntrustedCertificate;
-        }
-        else {
-            this.allowUntrustedCertificate = proxyUserNameOrallowUntrustedCertificate;
-        }
-    }
-
-    SetProvider(provider: IProvider): void {
-        this.provider = provider;
-    }
-
-    private provider: IProvider = null;
-
-
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        //setup xhr for github.com/andris9/fetch options
-        let options: IXHROptions = <any>{
-            url: xhroptions.url,
-            body: xhroptions.data,
-            headers: xhroptions.headers,
-            method: <any>xhroptions.type,
-            followRedirect: false,
-            //resolveWithFullResponse: true
-        }
-
-        let proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
-        }
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-
-            let _promise: Promise<IXHROptions> = Promise.resolve(options);
-
-            if (this.provider) {
-                _promise = this.provider.preCall(options);
-            }
-
-            _promise.then(opt => {
-                console.log("in proxy");
-                console.log(opt);
-                request(opt || options, (error, response, body) => {
-
-                    if (error) {
-                        rejectWithError(reject, error);
-                    }
-                    else {
-                        let xhrResponse: XMLHttpRequest = <any>{
-                            response: body ? body.toString() : '',
-                            status: response.statusCode,
-                            //redirectCount: meta.redirectCount,
-                            headers: response.headers,
-                            finalUrl: response.url,
-                            responseType: '',
-                            statusText: response.statusMessage,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve(setupXhrResponse(xhrResponse));
-                        }
-                        else {
-                            reject(setupXhrResponse(xhrResponse));
-                        }
-                    }
-                });
-            }, reason => {
-                reject(setupXhrResponse(reason));
-            });
-        });
-
-    }
-
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        //setup xhr for github.com/andris9/fetch options
-        let options = {
-            url: xhroptions.url,
-            body: xhroptions.data,
-            headers: xhroptions.headers,
-            method: <any>xhroptions.type,
-            followRedirect: false,
-
-        }
-
-        let proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
-        }
-
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-            let _promise: Promise<IXHROptions> = Promise.resolve(options);
-
-            if (this.provider) {
-                _promise = this.provider.preCall(options);
-            }
-
-            _promise.then(opt => {
-                this.stream = request(options);
-
-                this.stream.on('response', function (response) {
-                    // unmodified http.IncomingMessage object
-                    progressDelegate({ type: "header", headers: response["headers"] })
-                })
-                this.stream.on("data", (chunk) => {
-                    // decompressed data as it is received
-                    // console.log('decoded chunk: ' + chunk)
-                    // console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-
-                this.stream.on("end", () => {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-
-                this.stream.on('error', (error) => {
-                    progressDelegate({ type: "error", error: error });
-                    this.disconnect();
-                    rejectWithError(reject, error);
-                });
-            }, reason => {
-                reject(setupXhrResponse(reason));
-            });
-        });
-    }
-
-    disconnect() {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
-    }
-
-    getProxyString(): string {
-        if (this.proxyUrl) {
-            let str: string = this.proxyUrl;
-            if (this.proxyUser && this.proxyPassword) {
-                let proxyParts = this.proxyUrl.split("://");
-
-                return (proxyParts[0] + "://" + this.proxyUser + ":" + this.proxyPassword + "@" + proxyParts[1]);
-
-            }
-            else {
-                return this.proxyUrl;
-            }
-        }
-        return null;
-    }
-
-
-}
-
-function rejectWithError(reject: Function, reason) {
-    let xhrResponse: XMLHttpRequest = <any>{
-        response: reason.response && reason.response.body ? reason.response.body.toString() : '',
-        status: reason.statusCode,
-        //redirectCount: meta.redirectCount,
-        headers: reason.response ? reason.response.headers : {},
-        finalUrl: reason.url,
-        responseType: '',
-        statusText: reason.message,
-        message: reason.message
-    };
-    if (typeof xhrResponse.status === 'undefined' && reason.message) {
-        try {
-            let parse: any[] = reason.message.match(/statusCode=(\d*?)$/)
-            if (parse && parse.length > 1) {
-                xhrResponse[<any>"status"] = Number(parse[1]);
-            }
-        } catch (e) { }
-    }
-    reject(setupXhrResponse(xhrResponse));
-}
diff --git a/node_modules/@ewsjs/xhr/src/xhrApi.ts b/node_modules/@ewsjs/xhr/src/xhrApi.ts
index 3700814..955ca81 100644
--- a/node_modules/@ewsjs/xhr/src/xhrApi.ts
+++ b/node_modules/@ewsjs/xhr/src/xhrApi.ts
@@ -1,7 +1,6 @@
-import * as request from 'request';
-import { CoreOptions } from "request";
-import * as  Promise from "bluebird";
-import { IXHROptions, IXHRApi, IXHRProgress } from "./ews.partial";
+import * as https from 'https';
+import axios, { AxiosRequestConfig, AxiosProxyConfig } from 'axios';
+import { IXHROptions, IXHRApi, IXHRProgress } from "../types/ews.partial";
 import { setupXhrResponse } from "./utils";
 
 import { IProvider } from "./IProvider";
@@ -17,288 +16,365 @@ import { CookieProvider } from './cookieProvider';
  */
 export class XhrApi implements IXHRApi {
 
-    static defaultOptions: CoreOptions = {};
-    requestOptions: CoreOptions = {};
-
-    private allowUntrustedCertificate: boolean;
-    /**
-     * @internal 
-     */
-    private stream: any;
-    private proxyConfig = {
-        enabled: false,
-        url: null,
-        userName: null,
-        password: null,
-    };
-
-    get apiName(): string {
-        let n = "request";
-        if (this.proxyConfig.enabled = true) {
-            n += ";proxy:yes";
-        }
-        if (this.authProvider) {
-            n += ";auth:" + this.authProvider.providerName;
-        }
-        return "request";
+  static defaultOptions: AxiosRequestConfig = {};
+  requestOptions: AxiosRequestConfig = {};
+
+  private allowUntrustedCertificate: boolean;
+  /**
+   * @internal 
+   */
+  private stream: any;
+  private proxyConfig = {
+    enabled: false,
+    url: null,
+    userName: null,
+    password: null,
+  };
+
+  get apiName(): string {
+    let n = "request";
+    if (this.proxyConfig.enabled) {
+      n += ";proxy:yes";
     }
-
-    /**
-     * Creates an instance of XhrApi optionally passing options for request
-     * @memberof XhrApi
-     */
-    constructor();
-    /**
-     * Creates an instance of XhrApi optionally passing options for request
-     * @param {CoreOptions} requestOptions Options for request
-     * @memberof XhrApi
-     */
-    constructor(requestOptions: CoreOptions);
-    /**
-     * Creates an instance of XhrApi. optionally pass true to bypass remote ssl/tls certificate check
-     * @param {boolean} allowUntrustedCertificate whether to allow non trusted certificate or not
-     * @memberof XhrApi
-     */
-    constructor(allowUntrustedCertificate: boolean);
-    constructor(aucoro: boolean | CoreOptions = false) {
-        if (typeof aucoro === 'object') {
-            this.requestOptions = aucoro;
-            this.allowUntrustedCertificate = !(typeof aucoro.rejectUnauthorized !== 'undefined' ? aucoro.rejectUnauthorized : true);
-        } else {
-            this.allowUntrustedCertificate = !!aucoro;
-        }
+    if (this.authProvider) {
+      n += ";auth:" + this.authProvider.providerName;
     }
-
-    /**
-     * Enable use of Proxy server when using this XHR Api
-     * 
-     * @param {string} url Proxy server url with port, usally http://server:8080 or https://server:port
-     * @param {string} [proxyUserName=null] proxy server authentication username
-     * @param {string} [proxyPassword=null] proxy server authentication password
-     * @returns {XhrApi} returns instance for chaining
-     * @memberof XhrApi
-     */
-    useProxy(url: string, proxyUserName: string = null, proxyPassword: string = null): XhrApi {
-        if (this.authProvider instanceof NtlmProvider) {
-            throw new Error("NtlmProvider does not work with proxy (yet!)")
-        }
-        this.proxyConfig = { enabled: url !== null, url: url, userName: proxyUserName, password: proxyPassword };
-        return this;
+    return n;
+  }
+
+  /**
+   * Creates an instance of XhrApi optionally passing options for request
+   * @memberof XhrApi
+   */
+  constructor();
+  /**
+   * Creates an instance of XhrApi optionally passing options for request
+   * @param {CoreOptions} requestOptions Options for request
+   * @memberof XhrApi
+   */
+  constructor(requestOptions: AxiosRequestConfig & { rejectUnauthorized?: boolean });
+  /**
+   * Creates an instance of XhrApi. optionally pass true to bypass remote ssl/tls certificate check
+   * @param {boolean} allowUntrustedCertificate whether to allow non trusted certificate or not
+   * @memberof XhrApi
+   */
+  constructor(allowUntrustedCertificate: boolean);
+  constructor(aucoro: boolean | AxiosRequestConfig & { rejectUnauthorized?: boolean } = false) {
+    if (typeof aucoro === 'object') {
+      this.requestOptions = aucoro;
+      this.allowUntrustedCertificate = !(typeof aucoro.rejectUnauthorized !== 'undefined' ? aucoro.rejectUnauthorized : true);
+    } else {
+      this.allowUntrustedCertificate = !!aucoro;
     }
-
-    /**
-     * use NTLM authentication method, supports Ntlm v2
-     * 
-     * @param {string} username username for ntlm
-     * @param {string} password password for ntlm
-     * @returns {XhrApi} returns instance for chaining
-     * @memberof XhrApi
-     */
-    useNtlmAuthentication(username: string, password: string): XhrApi {
-        if (this.proxyConfig.enabled === true) {
-            throw new Error("NtlmProvider does not work with proxy (yet!)")
-        }
-        this.authProvider = new NtlmProvider(username, password);
-        return this;
+  }
+
+  /**
+   * Enable use of Proxy server when using this XHR Api
+   * 
+   * @param {string} url Proxy server url with port, usally http://server:8080 or https://server:port
+   * @param {string} [proxyUserName=null] proxy server authentication username
+   * @param {string} [proxyPassword=null] proxy server authentication password
+   * @returns {XhrApi} returns instance for chaining
+   * @memberof XhrApi
+   */
+  useProxy(url: string, proxyUserName: string = null, proxyPassword: string = null): XhrApi {
+    if (this.authProvider instanceof NtlmProvider) {
+      throw new Error("NtlmProvider does not work with proxy (yet!)")
     }
-
-    /**
-     * use cookies authentication method, usually required when hosted behind ISA/TMG
-     * 
-     * @param {string} username username for cookies auth
-     * @param {string} password password for cookies auth
-     * @returns {XhrApi} returns instance for chaining
-     * @memberof XhrApi
-     */
-    useCookieAuthentication(username: string, password: string): XhrApi {
-        this.authProvider = new CookieProvider(username, password);
-        return this;
+    this.proxyConfig = { enabled: url !== null, url: url, userName: proxyUserName, password: proxyPassword };
+    return this;
+  }
+
+  /**
+   * use NTLM authentication method, supports Ntlm v2
+   * 
+   * @param {string} username username for ntlm
+   * @param {string} password password for ntlm
+   * @returns {XhrApi} returns instance for chaining
+   * @memberof XhrApi
+   */
+  useNtlmAuthentication(username: string, password: string): XhrApi {
+    if (this.proxyConfig.enabled === true) {
+      throw new Error("NtlmProvider does not work with proxy (yet!)")
     }
-
-    /**
-     * set custom IProvider interface, needed for custom IProvider implementing custom precall method
-     * 
-     * @param {IProvider} authProvider auth provider implementing IProvider interface
-     * @memberof XhrApi
-     */
-    setAuthProvider(authProvider: IProvider): void {
-        this.authProvider = authProvider;
+    this.authProvider = new NtlmProvider(username, password);
+    return this;
+  }
+
+  /**
+   * use cookies authentication method, usually required when hosted behind ISA/TMG
+   * 
+   * @param {string} username username for cookies auth
+   * @param {string} password password for cookies auth
+   * @returns {XhrApi} returns instance for chaining
+   * @memberof XhrApi
+   */
+  useCookieAuthentication(username: string, password: string): XhrApi {
+    this.authProvider = new CookieProvider(username, password);
+    return this;
+  }
+
+  /**
+   * set custom IProvider interface, needed for custom IProvider implementing custom precall method
+   * 
+   * @param {IProvider} authProvider auth provider implementing IProvider interface
+   * @memberof XhrApi
+   */
+  setAuthProvider(authProvider: IProvider): void {
+    this.authProvider = authProvider;
+  }
+
+  /**@internal */
+  private authProvider: IProvider = null;
+
+
+  async xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
+    console.log('[DEBUG] XhrApi - Starting XHR request');
+    console.log('[DEBUG] XhrApi - Request URL:', xhroptions.url);
+    console.log('[DEBUG] XhrApi - Request method:', xhroptions.type);
+    console.log('[DEBUG] XhrApi - Request headers:', JSON.stringify(xhroptions.headers, null, 2));
+    console.log('[DEBUG] XhrApi - Request data:', xhroptions.data ? `${xhroptions.data.toString().substring(0, 200)}...` : 'No data');
+    console.log('[DEBUG] XhrApi - Allow redirect:', xhroptions.allowRedirect);
+    console.log('[DEBUG] XhrApi - Auth provider:', this.authProvider ? this.authProvider.providerName : 'None');
+    console.log('[DEBUG] XhrApi - Allow untrusted certificate:', this.allowUntrustedCertificate);
+
+    let client = axios.create();
+    //setup xhr for github.com/andris9/fetch options
+    let options: AxiosRequestConfig = {
+      url: xhroptions.url,
+      data: xhroptions.data,
+      headers: xhroptions.headers,
+      method: <any>xhroptions.type,
+      maxRedirects: !xhroptions.allowRedirect ? 0 : 5,
+      //resolveWithFullResponse: true
     }
 
-    /**@internal */
-    private authProvider: IProvider = null;
-
-
-    xhr(xhroptions: IXHROptions, progressDelegate?: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
+    if (this.allowUntrustedCertificate) {
+      options.httpsAgent = new https.Agent({ rejectUnauthorized: false });
+      console.log('[DEBUG] XhrApi - Using custom HTTPS agent with rejectUnauthorized: false');
+    }
 
-        //setup xhr for github.com/andris9/fetch options
-        let options: IXHROptions = <any>{
-            url: xhroptions.url,
-            body: xhroptions.data,
-            headers: xhroptions.headers,
-            method: <any>xhroptions.type,
-            followRedirect: !!xhroptions.allowRedirect,
-            //resolveWithFullResponse: true
-        }
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
+    let proxyConfig = this.getProxyOption();
+    if (proxyConfig) {
+      options["proxy"] = proxyConfig;
+      console.log('[DEBUG] XhrApi - Using proxy configuration:', JSON.stringify(proxyConfig, null, 2));
+    }
+    options = this.getOptions(options)
+
+    console.log('[DEBUG] XhrApi - Final options before auth:', JSON.stringify({
+      url: options.url,
+      method: options.method,
+      maxRedirects: options.maxRedirects,
+      headers: options.headers
+    }, null, 2));
+
+    let _promise: Promise<AxiosRequestConfig> = Promise.resolve(options);
+
+    try {
+      if (this.authProvider) {
+        console.log('[DEBUG] XhrApi - Calling auth provider preCall method');
+        _promise = this.authProvider.preCall({ ...options, rejectUnauthorized: !this.allowUntrustedCertificate });
+        client = this.authProvider.client || client;
+        console.log('[DEBUG] XhrApi - Auth provider client:', client ? 'Custom client' : 'Default client');
+      }
+      
+      const opt = await _promise;
+      console.log('[DEBUG] XhrApi - Options after auth preCall:', JSON.stringify({
+        url: opt.url,
+        method: opt.method,
+        headers: opt.headers
+      }, null, 2));
+
+      console.log('[DEBUG] XhrApi - Executing final HTTP request');
+      const response = await client(opt || options as any);
+
+      console.log('[DEBUG] XhrApi - HTTP request completed successfully');
+      console.log('[DEBUG] XhrApi - Response status:', response.status);
+      console.log('[DEBUG] XhrApi - Response statusText:', response.statusText);
+      console.log('[DEBUG] XhrApi - Response headers:', JSON.stringify(response.headers, null, 2));
+      console.log('[DEBUG] XhrApi - Response data length:', response.data ? response.data.toString().length : 0);
+      console.log('[DEBUG] XhrApi - Response data preview:', response.data ? response.data.toString().substring(0, 300) + '...' : 'No data');
+
+      let xhrResponse: XMLHttpRequest = <any>{
+        response: response.data ? response.data.toString() : '',
+        status: response.status,
+        //redirectCount: meta.redirectCount,
+        headers: response.headers,
+        finalUrl: response.headers.location || response.request.res.responseUrl,
+        responseType: '',
+        statusText: response.statusText,
+      };
+      if (xhrResponse.status === 200) {
+        console.log('[DEBUG] XhrApi - Request successful, returning response');
+        return setupXhrResponse(xhrResponse);
+      }
+      else {
+        console.log('[DEBUG] XhrApi - Request failed with non-200 status, throwing error');
+        throw setupXhrResponse(xhrResponse);
+      }
+    } catch (error) {
+      console.log('[DEBUG] XhrApi - Request failed with exception:');
+      console.log('[DEBUG] XhrApi - Error type:', typeof error);
+      console.log('[DEBUG] XhrApi - Error message:', error.message);
+      console.log('[DEBUG] XhrApi - Error code:', error.code);
+      console.log('[DEBUG] XhrApi - Error stack:', error.stack);
+      
+      if (error.response) {
+        console.log('[DEBUG] XhrApi - Error response status:', error.response.status);
+        console.log('[DEBUG] XhrApi - Error response statusText:', error.response.statusText);
+        console.log('[DEBUG] XhrApi - Error response headers:', JSON.stringify(error.response.headers, null, 2));
+        console.log('[DEBUG] XhrApi - Error response data:', error.response.data);
+      } else if (error.request) {
+        console.log('[DEBUG] XhrApi - Error request config:', JSON.stringify({
+          url: error.request.url,
+          method: error.request.method,
+          headers: error.request.headers
+        }, null, 2));
+      }
+
+      console.log('[DEBUG] XhrApi - Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
+      throw setupXhrResponse(error)
+    }
 
-        // if (this.allowUntrustedCertificate) {
-        //     options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        // }
 
-        let proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
-        }
-        options = this.getOptions(options)
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-
-            let _promise: Promise<IXHROptions> = Promise.resolve(options);
-
-            if (this.authProvider) {
-                _promise = this.authProvider.preCall(options);
-            }
-            _promise.then(opt => {
-                // console.log("in proxy");
-                // console.log(opt);
-                request(opt || options, (error, response, body) => {
-                    if (error) {
-                        rejectWithError(reject, error);
-                    }
-                    else {
-                        let xhrResponse: XMLHttpRequest = <any>{
-                            response: body ? body.toString() : '',
-                            status: response.statusCode,
-                            //redirectCount: meta.redirectCount,
-                            headers: response.headers,
-                            finalUrl: response.url,
-                            responseType: '',
-                            statusText: response.statusMessage,
-                        };
-                        if (xhrResponse.status === 200) {
-                            resolve(setupXhrResponse(xhrResponse));
-                        }
-                        else {
-                            reject(setupXhrResponse(xhrResponse));
-                        }
-                    }
-                });
-            }, reason => {
-                reject(setupXhrResponse(reason));
-            });
-        });
+  }
 
+  xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
+    let client = axios.create();
+    //setup xhr for github.com/andris9/fetch options
+    let options: AxiosRequestConfig = {
+      url: xhroptions.url,
+      data: xhroptions.data,
+      headers: xhroptions.headers,
+      method: <any>xhroptions.type,
+      maxRedirects: !xhroptions.allowRedirect ? 0 : 5,
+      responseType: 'stream',
     }
 
-    xhrStream(xhroptions: IXHROptions, progressDelegate: (progressData: IXHRProgress) => void): Promise<XMLHttpRequest> {
-
-        //setup xhr for github.com/andris9/fetch options
-        let options = {
-            url: xhroptions.url,
-            body: xhroptions.data,
-            headers: xhroptions.headers,
-            method: <any>xhroptions.type,
-            followRedirect: false,
+    if (this.allowUntrustedCertificate) {
+      options.httpsAgent = new https.Agent({ rejectUnauthorized: false });
+    }
 
-        }
+    let proxyConfig = this.getProxyOption();
+    if (proxyConfig) {
+      options["proxy"] = proxyConfig;
+    }
+    options = this.getOptions(options)
+
+    return new Promise<XMLHttpRequest>((resolve, reject) => {
+
+      let _promise: Promise<AxiosRequestConfig> = Promise.resolve(options);
+
+      if (this.authProvider) {
+        _promise = this.authProvider.preCall({ ...options, rejectUnauthorized: !this.allowUntrustedCertificate });
+        client = this.authProvider.client || client;
+      }
+
+      _promise.then(async opt => {
+        const response = await client(opt || options)
+        this.stream = response.data;
+
+        this.stream.on('response', function (response) {
+          // unmodified http.IncomingMessage object
+          progressDelegate({ type: "header", headers: response["headers"] })
+        })
+        this.stream.on("data", (chunk) => {
+          // decompressed data as it is received
+          // console.log('decoded chunk: ' + chunk)
+          // console.log(chunk.toString());
+          progressDelegate({ type: "data", data: chunk.toString() });
+        });
 
-        options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
+        this.stream.on("end", () => {
+          progressDelegate({ type: "end" });
+          resolve(null);
+        });
 
-        // if (this.allowUntrustedCertificate) {
-        //     options["rejectUnauthorized"] = !this.allowUntrustedCertificate;
-        // }
-        let proxyStr = this.getProxyString();
-        if (proxyStr) {
-            options["proxy"] = proxyStr;
-        }
-        options = this.getOptions(options)
-        return new Promise<XMLHttpRequest>((resolve, reject) => {
-
-            let _promise: Promise<IXHROptions> = Promise.resolve(options);
-
-            if (this.authProvider) {
-                _promise = this.authProvider.preCall(options);
-            }
-
-            _promise.then(opt => {
-                this.stream = request(opt || options);
-
-                this.stream.on('response', function (response) {
-                    // unmodified http.IncomingMessage object
-                    progressDelegate({ type: "header", headers: response["headers"] })
-                })
-                this.stream.on("data", (chunk) => {
-                    // decompressed data as it is received
-                    // console.log('decoded chunk: ' + chunk)
-                    // console.log(chunk.toString());
-                    progressDelegate({ type: "data", data: chunk.toString() });
-                });
-
-                this.stream.on("end", () => {
-                    progressDelegate({ type: "end" });
-                    resolve();
-                });
-
-                this.stream.on('error', (error) => {
-                    progressDelegate({ type: "error", error: error });
-                    this.disconnect();
-                    rejectWithError(reject, error);
-                });
-            }, reason => {
-                reject(setupXhrResponse(reason));
-            });
+        this.stream.on('error', (error) => {
+          progressDelegate({ type: "error", error: error });
+          this.disconnect();
+          rejectWithError(reject, error);
         });
+      }, reason => {
+        reject(setupXhrResponse(reason));
+      });
+    });
+  }
+
+  disconnect() {
+    if (this.stream) {
+      try {
+        this.stream.destroy();
+      }
+      catch (e) { }
     }
-
-    disconnect() {
-        if (this.stream) {
-            try {
-                this.stream.destroy();
-            }
-            catch (e) { }
-        }
+  }
+
+  private getProxyString(): string {
+    if (this.proxyConfig.enabled) {
+      let url: string = this.proxyConfig.url;
+      if (this.proxyConfig.userName && this.proxyConfig.password) {
+        let proxyParts = url.split("://");
+        return (proxyParts[0] + "://" + encodeURIComponent(this.proxyConfig.userName) + ":" + encodeURIComponent(this.proxyConfig.password) + "@" + proxyParts[1]);
+      }
+      else {
+        return url;
+      }
     }
-
-    private getProxyString(): string {
-        if (this.proxyConfig.enabled) {
-            let url: string = this.proxyConfig.url;
-            if (this.proxyConfig.userName && this.proxyConfig.password) {
-                let proxyParts = url.split("://");
-                return (proxyParts[0] + "://" + encodeURIComponent(this.proxyConfig.userName) + ":" + encodeURIComponent(this.proxyConfig.password) + "@" + proxyParts[1]);
-            }
-            else {
-                return url;
-            }
+    return null;
+  }
+
+  private getProxyOption(): AxiosProxyConfig {
+    if (this.proxyConfig.enabled) {
+      let url: string = this.proxyConfig.url;
+      let proxyParts = new URL(url);
+      if (this.proxyConfig.userName && this.proxyConfig.password) {
+        return {
+          protocol: proxyParts.protocol,
+          host: proxyParts.host,
+          port: proxyParts.port ? Number(proxyParts.port) : 80,
+          auth: {
+            username: this.proxyConfig.userName,
+            password: this.proxyConfig.password
+          }
+        };
+      }
+      else {
+        return {
+          protocol: proxyParts.protocol,
+          host: proxyParts.host,
+          port: proxyParts.port ? Number(proxyParts.port) : 80,
         }
-        return null;
+      }
     }
+    return null;
+  }
 
-    private getOptions(opts: CoreOptions) {
-        let headers = Object.assign({}, (XhrApi.defaultOptions || {}).headers, (this.requestOptions || {}).headers, (opts || {}).headers)
-        return Object.assign({}, XhrApi.defaultOptions, this.requestOptions, opts, { headers });
-    }
+  private getOptions(opts: AxiosRequestConfig) {
+    let headers = Object.assign({}, (XhrApi.defaultOptions || {}).headers, (this.requestOptions || {}).headers, (opts || {}).headers)
+    return Object.assign({}, XhrApi.defaultOptions, this.requestOptions, opts, { headers });
+  }
 }
 
 
 function rejectWithError(reject: Function, reason) {
-    let xhrResponse: XMLHttpRequest = <any>{
-        response: reason.response && reason.response.body ? reason.response.body.toString() : '',
-        status: reason.statusCode,
-        //redirectCount: meta.redirectCount,
-        headers: reason.response ? reason.response.headers : {},
-        finalUrl: reason.url,
-        responseType: '',
-        statusText: reason.message,
-        message: reason.message
-    };
-    if (typeof xhrResponse.status === 'undefined' && reason.message) {
-        try {
-            let parse: any[] = reason.message.match(/statusCode=(\d*?)$/)
-            if (parse && parse.length > 1) {
-                xhrResponse[<any>"status"] = Number(parse[1]);
-            }
-        } catch (e) { }
-    }
-    reject(setupXhrResponse(xhrResponse));
+  let xhrResponse: XMLHttpRequest = <any>{
+    response: reason.response && reason.response.body ? reason.response.body.toString() : '',
+    status: reason.statusCode,
+    //redirectCount: meta.redirectCount,
+    headers: reason.response ? reason.response.headers : {},
+    finalUrl: reason.url,
+    responseType: '',
+    statusText: reason.message,
+    message: reason.message
+  };
+  if (typeof xhrResponse.status === 'undefined' && reason.message) {
+    try {
+      let parse: any[] = reason.message.match(/statusCode=(\d*?)$/)
+      if (parse && parse.length > 1) {
+        xhrResponse[<any>"status"] = Number(parse[1]);
+      }
+    } catch (e) { }
+  }
+  reject(setupXhrResponse(xhrResponse));
 }
diff --git a/node_modules/@ewsjs/xhr/test/test-ntlmProvider.js b/node_modules/@ewsjs/xhr/test/test-ntlmProvider.js
deleted file mode 100644
index d2f2556..0000000
--- a/node_modules/@ewsjs/xhr/test/test-ntlmProvider.js
+++ /dev/null
@@ -1,20 +0,0 @@
-const {XhrApi} = require('../src/');
-
-describe('NTLM Provider Tests', function() {
-    this.timeout(1000);
-
-     it('Error in preCall response handler properly rejects promise', function (done) {
-        const xhrApi = new XhrApi().useNtlmAuthentication('foo', 'bar');
-        const result = xhrApi.xhr({
-            type: 'GET',
-            url: 'https://outlook.office365.com/EWS/Exchange.asmx',  // This will cause decodeType2Message to fail
-            data: {},
-            headers: {},
-        }).then(function (result) {
-            done(new Error('Request unexpectedly succeeed.'));
-        }).catch(function (err) {
-            done();
-        });
-    });
-
- });
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/tsconfig.json b/node_modules/@ewsjs/xhr/tsconfig.json
index 2f11419..bde77b1 100644
--- a/node_modules/@ewsjs/xhr/tsconfig.json
+++ b/node_modules/@ewsjs/xhr/tsconfig.json
@@ -1,17 +1,19 @@
 {
-    "compilerOptions": {
-        "target": "es5",
-        "module": "commonjs",
-        "declaration": true,
-        "stripInternal": true,
-        "removeComments": false,
-        "outDir": "dist",
-        "lib": [
-            "es2015", "dom"
-        ]
-    },
-    "exclude": [
-        "dist",
-        "node_modules"
+  "compilerOptions": {
+    "target": "ES2020",
+    "module": "commonjs",
+    "declaration": true,
+    "stripInternal": true,
+    "removeComments": false,
+    "skipLibCheck": true,
+    "outDir": "dist",
+    "lib": [
+      "es2015",
+      "dom"
     ]
+  },
+  "exclude": [
+    "dist",
+    "node_modules"
+  ]
 }
\ No newline at end of file
diff --git a/node_modules/@ewsjs/xhr/dist/ews.partial.d.ts b/node_modules/@ewsjs/xhr/types/ews.partial.d.ts
similarity index 92%
rename from node_modules/@ewsjs/xhr/dist/ews.partial.d.ts
rename to node_modules/@ewsjs/xhr/types/ews.partial.d.ts
index 66c34b5..a598b52 100644
--- a/node_modules/@ewsjs/xhr/dist/ews.partial.d.ts
+++ b/node_modules/@ewsjs/xhr/types/ews.partial.d.ts
@@ -1,4 +1,3 @@
-import * as Promise from "bluebird";
 export interface IXHROptions {
     type?: string;
     url: string;
